diff --git a/out/replicache.js b/out/replicache.js
index 6c604a87951886c6c932a3bbf80ee8783aae401a..eaa12cc08af5e39b080586d8d53f74df66b76575 100644
--- a/out/replicache.js
+++ b/out/replicache.js
@@ -4,7 +4,7 @@ Error:
 `,t):e.error?.(`Mutation recovery error during:
 ${n}
 Error:
-`,t)}async function uu(t,e,n,r,o,s){f(r.replicacheFormatVersion===4),to(t);let{delegate:i,lc:a,wrapInOnlineCheck:l,wrapInReauthRetries:u,isPushDisabled:c,isPullDisabled:d}=o,p=i.clientID;if(p===e||t.lastServerAckdMutationID>=t.mutationID)return;let m=`Recovering mutations for ${e}.`;a.debug?.("Start:",m);let g=new Te(n,hi,vr,q);try{if(await v(g,w=>w.setHead(N,t.headHash)),c()){a.debug?.(`Cannot recover mutations for client ${e} because push is disabled.`);return}let{pusher:y}=i,S="recoveringMutationsPush";if(!await l(async()=>{let{result:w}=await u(async(O,k)=>{mr(g);let x=await Ut(O,g,k,await i.profileID,void 0,e,y,r.schemaVersion,Xn);return{result:x,httpRequestInfo:x?.httpRequestInfo}},S,a);return!!w&&w.httpRequestInfo.httpStatusCode===200},S)){a.debug?.(`Failed to recover mutations for client ${e} due to a push error.`);return}if(d()){a.debug?.(`Cannot confirm mutations were recovered for client ${e} because pull is disabled.`);return}let{puller:b}=i,I="recoveringMutationsPull",C;if(!await l(async()=>{let{result:w}=await u(async(O,k)=>{let x=await ai(await i.profileID,e,r.schemaVersion,b,O,g,s,k,!1);return{result:x,httpRequestInfo:x.httpRequestInfo}},I,a);return{pullResponse:C}=w,!!C&&w.httpRequestInfo.httpStatusCode===200},I)){a.debug?.(`Failed to recover mutations for client ${e} due to a pull error.`);return}return a.debug&&C&&(U(C)?a.debug?.(`Client ${p} cannot recover mutations for client ${e}. The client no longer exists on the server.`):K(C)?a.debug?.(`Version is not supported on the server. versionType: ${C.versionType}. Cannot recover mutations for client ${e}.`):a.debug?.(`Client ${p} recovered mutations for client ${e}.  Details`,{mutationID:t.mutationID,lastServerAckdMutationID:t.lastServerAckdMutationID,lastMutationID:C.lastMutationID})),await v(n,async w=>{let O=await W(w),k=O.get(e);if(!k)return O;to(k);let x=async z=>(await ye(z,w),z);if(U(C)||K(C)){let z=new Map(O);return z.delete(e),x(z)}if(f(C),k.lastServerAckdMutationID>=C.lastMutationID)return O;let J=new Map(O).set(e,{...k,lastServerAckdMutationID:C.lastMutationID});return x(J)})}catch(y){_t(y,a,m,i)}finally{await g.close(),a.debug?.("End:",m)}}async function cu(t,e,n,r){let o=r(t.name),s=new Se(o,G,q);try{await mi(t,e,s,n)}finally{await s.close()}}function mi(t,e,n,r){return t.replicacheFormatVersion>=5?du(t,e,n):pu(t,e,n,r)}async function pu(t,e,n,r){let{delegate:o,lc:s}=e,i=`Recovering mutations from db ${t.name}.`;s.debug?.("Start:",i);try{let a=Hr(t.replicacheFormatVersion),l=r||await V(n,c=>W(c)),u=new Set;for(;l;){let c;for(let[d,p]of l){if(o.closed){s.debug?.("Exiting early due to close:",i);return}if(!u.has(d)&&(u.add(d),c=await uu(p,d,n,t,e,a),c))break}l=c}}catch(a){_t(a,s,i,o)}s.debug?.("End:",i)}async function du(t,e,n){let{delegate:r,lc:o}=e,s=`Recovering mutations from db ${t.name}.`;o.debug?.("Start:",s);try{let i=Hr(t.replicacheFormatVersion),a=await V(n,u=>ee(u)),l=new Set;for(;a;){let u;for(let[c,d]of a){if(r.closed){o.debug?.("Exiting early due to close:",s);return}if(!l.has(c)&&(l.add(c),u=await hu(d,c,n,t,e,i),u))break}a=u}}catch(i){_t(i,o,s,r)}o.debug?.("End:",s)}function pi(t){return U(t)||K(t)}async function di(t,e,n,r,o){U(r)?t.debug?.(`Client group ${e} cannot recover mutations for client group ${n}. The client group is unknown on the server. Marking it as disabled.`):K(r)&&t.debug?.(`Client group ${e} cannot recover mutations for client group ${n}. The client group's version is not supported on the server. versionType: ${r.versionType}. Marking it as disabled.`),await v(o,s=>yn(n,s))}async function hu(t,e,n,r,o,s){f(r.replicacheFormatVersion>=5);let{delegate:i,lc:a,wrapInOnlineCheck:l,wrapInReauthRetries:u,isPushDisabled:c,isPullDisabled:d}=o,p=await o.clientGroupIDPromise;if(mr(p),p===e)return;let m,g=!0;for(let[D,b]of Object.entries(t.mutationIDs))if(!t.lastServerAckdMutationIDs[D]||t.lastServerAckdMutationIDs[D]<b){m=D,g=!1;break}if(g)return;if(t.disabled){a.debug?.(`Not recovering mutations for client group ${e} because group is disabled.`);return}let y=`Recovering mutations for client group ${e}.`;a.debug?.("Start:",y);let S=new Te(n,hi,vr,q);try{if(await v(S,k=>k.setHead(N,t.headHash)),c()){a.debug?.(`Cannot recover mutations for client group ${e} because push is disabled.`);return}let{pusher:D}=i,b="recoveringMutationsPush";if(!await l(async()=>{let{result:k}=await u(async(J,z)=>{f(m),f(S);let te=await Ut(J,S,z,await i.profileID,e,m,D,r.schemaVersion,ot);return{result:te,httpRequestInfo:te?.httpRequestInfo}},b,a);if(!k)return!1;let x=k.response;return pi(x)?(await di(a,p,e,x,n),!1):k.httpRequestInfo.httpStatusCode===200},b)){a.debug?.(`Failed to recover mutations for client ${e} due to a push error.`);return}if(d()){a.debug?.(`Cannot confirm mutations were recovered for client ${e} because pull is disabled.`);return}let{puller:C}=i,P="recoveringMutationsPull",w;if(!await l(async()=>{let{result:k}=await u(async(J,z)=>{f(m);let te=await Yn(await i.profileID,m,e,r.schemaVersion,C,J,S,s,z,!1);return{result:te,httpRequestInfo:te.httpRequestInfo}},P,a),{pullResponse:x}=k;return pi(x)?(await di(a,p,e,x,n),!1):!x||k.httpRequestInfo.httpStatusCode!==200?!1:(w=x,!0)},P)){a.debug?.(`Failed to recover mutations for client ${e} due to a pull error.`);return}return f(w),a.debug?.(`Client group ${p} recovered mutations for client group ${e}.  Details`,{mutationIDs:t.mutationIDs,lastServerAckdMutationIDs:t.lastServerAckdMutationIDs,lastMutationIDChanges:w.lastMutationIDChanges}),await v(n,async k=>{let x=await ee(k),J=x.get(e);if(!J)return x;f(w);let z={},te=!1;for(let[Wt,$t]of Object.entries(w.lastMutationIDChanges))(J.lastServerAckdMutationIDs[Wt]??0)<$t&&(z[Wt]=$t,te=!0);if(!te)return x;let at=new Map(x).set(e,{...J,lastServerAckdMutationIDs:{...J.lastServerAckdMutationIDs,...z}});return await mn(at,k),at})}catch(D){_t(D,a,y,i)}finally{await S.close(),a.debug?.("End:",y)}}var Co=class{name;onmessage=null;onmessageerror=null;constructor(e){this.name=e}addEventListener(){}removeEventListener(){}dispatchEvent(){return!1}close(){}postMessage(){}},Kt=typeof BroadcastChannel>"u"?Co:BroadcastChannel;function mu(t){return`replicache-new-client-group:${t}`}function fu(t){return`replicache-new-client-group-v1:${t}`}function yu(t){return typeof t=="object"&&typeof t.clientGroupID=="string"&&typeof t.idbName=="string"}function fi(t,e,n,r,o,s,i){if(n.aborted)return;let a=new Kt(fu(t));if(o){a.postMessage({clientGroupID:r,idbName:e});let l=new Kt(mu(t));l.postMessage([r]),l.close()}a.onmessage=async l=>{let{data:u}=l;if(yu(u)){let{clientGroupID:c,idbName:d}=u;if(c!==r)if(d===e)await V(i,async m=>await ke(c,m)!==void 0)&&s();else{s();return}}},n.addEventListener("abort",()=>a.close())}function gu(t){return`replicache-on-persist:${t}`}function Du(t){M(t),R(t.clientGroupID),R(t.clientID)}function yi(t,e,n){if(e.aborted)return()=>{};let r=new Kt(gu(t));return r.onmessage=o=>{let{data:s}=o;Du(s),n({clientGroupID:s.clientGroupID,clientID:s.clientID})},e.addEventListener("abort",()=>{r.close()}),o=>{e.aborted||(r.postMessage(o),n(o))}}async function gi(t){let e=await ze(N,t);return(await On(e,t)).map(r=>({id:r.meta.mutationID,name:r.meta.mutatorName,args:r.meta.mutatorArgsJSON,clientID:r.meta.clientID})).reverse()}var Su=7*24*60*60*1e3,Iu=5*60*1e3,Di;function Si(t,e,n,r){ae("ClientGC",()=>(Di=bu(t,e),Di),()=>Iu,n,r)}function bu(t,e){return v(e,async n=>{let r=Date.now(),o=await W(n),s=Array.from(o).filter(([a,l])=>a===t||r-l.heartbeatTimestampMs<=Su);if(s.length===o.size)return o;let i=new Map(s);return await ye(i,n),i})}var Cu=5*60*1e3,Ii;function bi(t,e,n){ae("ClientGroupGC",()=>(Ii=wu(t),Ii),()=>Cu,e,n)}function wu(t){return v(t,async e=>{let n=await W(e),r=new Set;for(let s of n.values())$e(s),r.add(s.clientGroupID);let o=new Map;for(let[s,i]of await ee(e))(r.has(s)||fn(i))&&o.set(s,i);return await mn(o,e),o})}var xu=60*1e3,Ci;function wi(t,e,n,r,o){ae("Heartbeat",async()=>{Ci=Ru(t,e);try{return await Ci}catch(s){if(s instanceof Y){n();return}throw s}},()=>xu,r,o)}function Ru(t,e){return v(e,async n=>{let r=await W(n),o=r.get(t);if(!o)throw new Y(t);let s={...o,heartbeatTimestampMs:Date.now()},i=new Map(r).set(t,s);return await ye(i,n),i})}var st=class{#e=new Set;#t;constructor(e){this.#t=e}async visit(e){if(this.#e.has(e))return;this.#e.add(e);let n=await this.#t.mustGetChunk(e);await this.visitChunk(n)}async visitChunk(e){await Promise.all(e.meta.map(n=>this.visit(n)))}};var Qn=class extends st{#e=new Map;#t;constructor(e){super(e),this.#t=e}get gatheredChunks(){return this.#e}visit(e){return this.#t.isMemOnlyChunkHash(e)?super.visit(e):A}visitChunk(e){return this.#e.set(e.hash,e),super.visitChunk(e)}};async function ki(t,e,n,r,o,s,i,a=()=>Promise.resolve()){if(s())return;let[l,u,c]=await V(r,async y=>{await Ls(e,y);let S=await oo(e,y);f(S,`No main client group for clientID: ${e}`);let[,D]=await xi(y,S),b=await D.getMutationID(e,y),I=await Ve(D,y);return ue(I),[b,I,S]});if(s())return;let[d,p,m]=await V(n,async y=>{let S=await Ke(N,y),D=await Vn(S,{[e]:l||0},y),b=await Ve(S,y);ue(b);let I;if(kt(b,u)>0){await a();let C=b.chunk.hash,P=new Qn(y);await P.visit(C),I=P.gatheredChunks}return[D,b,I]});if(s())return;let g=!1;await v(r,async y=>{let[S,D]=await xi(y,c),b=D.chunk.hash,I={...S.mutationIDs},{lastServerAckdMutationIDs:C}=S;if(m){let w=await Et(e,y);$e(w);let O=await Ve(D,y);if(ue(O),kt(p,O)>0){g=!0,await Promise.all(Array.from(m.values(),x=>y.putChunk(x))),await Tt(e,{...w,persistHash:p.chunk.hash},y),b=p.chunk.hash;let k=await On(S.headHash,y);C=p.meta.lastMutationIDs,I={...C},b=await Ri(k,b,y,o,I,t,i)}}b=await Ri(d,b,y,o,I,t,i);let P={...S,headHash:b,mutationIDs:I,lastServerAckdMutationIDs:C};await Dt(c,P,y)}),m&&g&&await v(n,y=>y.chunksPersisted([...m.keys()]))}async function xi(t,e){let n=await ke(e,t);return f(n,`No client group for clientGroupID: ${e}`),[n,await H(n.headHash,t)]}async function Ri(t,e,n,r,o,s,i){for(let a=t.length-1;a>=0;a--){let l=t[a],{meta:u}=l,c=await H(e,n);await l.getMutationID(u.clientID,n)>await c.getMutationID(u.clientID,n)&&(o[u.clientID]=u.mutationID,e=(await $n(l,n,e,r,s,u.clientID,i)).chunk.hash)}return e}var er=class extends st{#e=new Map;#t=0;#n;#r;#o;constructor(e,n,r,o=fe){super(e),this.#n=n,this.#r=r,this.#o=o}get gatheredChunks(){return this.#e}visit(e){return this.#t>=this.#r||this.#n.isCached(e)?A:super.visit(e)}visitChunk(e){if(this.#t<this.#r){let n=this.#o(e);this.#e.set(e.hash,{chunk:e,size:n}),this.#t+=n}return super.visitChunk(e)}};var ku=5*2**20,Mu=300;async function Pi(t,e,n,r,o,s,i,a){if(i())return;let l=await V(e,d=>ms(N,d));ue(l);let u=await e.withSuspendedSourceCacheEvictsAndDeletes(async()=>{let d=await v(n,async D=>{let b=await zs(r,D);if(!b)throw new Y(r);let I=b.headHash,P=await(await H(I,D)).getMutationID(r,D),w=await Et(r,D);$e(w);let O=await B(I,D);if(ue(O),Mi(l,O,I))return;let k=new er(D,e,ku);await k.visit(I);let{gatheredChunks:x}=k,J=new Set(w.refreshHashes);J.add(I);let z={...w,refreshHashes:[...J]};return await Tt(r,z,D),[I,O,P,x,w.refreshHashes]});if(i()||!d)return{type:"aborted"};if(await ce(Mu),i())return{type:"aborted"};let[p,m,g,y,S]=d;return v(e,async D=>{let b=await Ke(N,D),I=await Ve(b,D);if(ue(I),Mi(I,m,p))return{type:"aborted",refreshHashesForRevert:S};let C=await Vn(b,{[r]:g},D),P=[];for(let{chunk:x,size:J}of y.values())P.push(D.putChunk(x,J));await Promise.all(P);let w=p;for(let x=C.length-1;x>=0;x--)w=(await $n(C[x],D,w,o,t,C[x].meta.clientID,a)).chunk.hash;let O=await H(w,D),k=await Ps(b,O,D,s,a);return await D.setHead(N,w),{type:"complete",diffs:k,newPerdagClientHeadHash:p}})});if(i())return;let c=d=>v(n,async p=>{let g={...await Et(r,p),refreshHashes:d};await Tt(r,g,p)});if(u.type==="aborted"){u.refreshHashesForRevert&&await c(u.refreshHashesForRevert);return}return await c([u.newPerdagClientHeadHash]),u.diffs}function Mi(t,e,n){let r=kt(t,e);return r>0||r===0&&n===e.chunk.hash}import{resolver as Pu}from"@rocicorp/resolver";function vi(t){return new Promise(e=>{typeof requestIdleCallback=="function"?requestIdleCallback(()=>e(),{timeout:t}):setTimeout(()=>e(),t)})}var Bt=class{#e;#t;#n;#r;#o;#i=void 0;#a=void 0;#u=Promise.resolve();#l=Promise.resolve();constructor(e,n,r,o,s=vi){this.#e=e,this.#t=n,this.#n=r,this.#r=o,this.#o=s,this.#r.addEventListener("abort",()=>{let i=new Z("Aborted");this.#a?.reject(i),this.#i?.reject(i),this.#a=void 0,this.#i=void 0})}schedule(){return this.#r.aborted?Promise.reject(new Z("Aborted")):this.#i?this.#i.promise:(this.#i=Pu(),this.#p(),this.#i.promise)}async#p(){try{await this.#u}catch{}if(await this.#l,!!this.#i&&(await this.#o(this.#t),!!this.#i)){this.#l=vu(this.#n,this.#r),this.#a=this.#i,this.#i=void 0;try{this.#u=this.#e(),await this.#u,this.#a?.resolve()}catch(e){this.#a?.reject(e)}this.#a=void 0}}};async function vu(t,e){try{await ce(t,e)}catch(n){f(n instanceof Z)}}function Ni(t,e,n){let r=setInterval(t,e);n.addEventListener("abort",()=>{clearInterval(r)})}async function wo(t,e,n,r){let o=await fetch(e,{method:t,body:n,headers:r});if(!o.ok)throw new Error(`Got ${o.status} fetching ${e}: ${await o.text()}`);return o}var Nu=new Set,Oi=Symbol(),tr=class{#e;#t;#n=Oi;#r=Nu;#o=[];onError;onDone;#i;constructor(e,n,r,o,s=$){this.#e=e,this.#t=n,this.onError=r,this.onDone=o,this.#i=s}hasIndexSubscription(e){for(let n of this.#o)if(n.options.indexName===e)return!0;return!1}invoke(e,n,r){return this.#e(e)}matches(e){for(let[n,r]of e)if(Ou(this.#r,this.#o,n,r))return!0;return!1}updateDeps(e,n){this.#r=e,this.#o=n}onData(e){(this.#n===Oi||!this.#i(this.#n,e))&&(this.#n=e,this.#t(e))}};var nr=class{#e;#t;#n;#r;onError=void 0;onDone=void 0;constructor(e,n){this.#e=e,this.#t=n?.prefix??"",this.#n=n?.indexName,this.#r=n?.initialValuesInFirstDiff??!1}hasIndexSubscription(e){return this.#n===e}onData(e){e!==void 0&&this.#e(e)}invoke(e,n,r){let o=async(s,i,a,l)=>{let u;if(n===0){if(!this.#r)return;f(r===void 0);let p=[];for await(let m of e.scan({prefix:i,indexName:s}).entries())p.push({op:"add",key:m[0],newValue:m[1]});u=p}else{f(r);let p=r.get(s??"")??[];u=l(p)}let c=[],{length:d}=u;for(let p=Ei(u,i,a);p<d&&a(u[p]).startsWith(i);p++)c.push(u[p]);return n===0||c.length>0?c:void 0};return this.#n?o(this.#n,this.#t,s=>s.key[0],s=>Vi(s,qe)):o(void 0,this.#t,s=>s.key,s=>Vi(s,i=>i))}matches(e){let n=e.get(this.#n??"");return n===void 0?!1:Tu(n,this.#t,this.#n)}updateDeps(e,n){}};function Vi(t,e){return t.map(n=>{let r=e(n.key);switch(n.op){case"add":return{op:"add",key:r,newValue:n.newValue};case"change":return{op:"change",key:r,oldValue:n.oldValue,newValue:n.newValue};case"del":return{op:"del",key:r,oldValue:n.oldValue}}})}var rr=class{#e=new Set;#t=new Set;#n;#r;hasPendingSubscriptionRuns=!1;constructor(e,n){this.#n=e,this.#r=n}add(e){return this.#e.add(e),this.#i(e),()=>this.#e.delete(e)}clear(){for(let e of this.#e)e.onDone?.();this.#e.clear()}async fire(e){let n=Eu(this.#e,e);await this.#o(n,1,e)}async#o(e,n,r){let o=[...e];if(o.length===0)return;let s=await this.#n(i=>Promise.allSettled(o.map(async a=>{let l=new Wn(i);try{return await a.invoke(l,n,r)}finally{a.updateDeps(l.keys,l.scans)}})));this.callCallbacks(o,s)}callCallbacks(e,n){for(let r=0;r<e.length;r++){let o=e[r],s=n[r];s.status==="fulfilled"?o.onData(s.value):o.onError?o.onError(s.reason):this.#r.error?.("Error in subscription body:",s.reason)}}async#i(e){if(this.#t.add(e),!this.hasPendingSubscriptionRuns){this.hasPendingSubscriptionRuns=!0,await Promise.resolve(),this.hasPendingSubscriptionRuns=!1;let n=[...this.#t];this.#t.clear(),await this.#o(n,0,void 0)}}shouldComputeDiffs(){return this.#e.size>0}shouldComputeDiffsForIndex(e){for(let n of this.#e)if(n.hasIndexSubscription(e))return!0;return!1}};function Ou(t,e,n,r){if(n===""){for(let o of r)if(t.has(o.key))return!0}for(let o of e)if(Vu(o,n,r))return!0;return!1}function Vu(t,e,n){for(let r of n)if(Hu(t,e,r.key))return!0;return!1}function Hu(t,e,n){let{indexName:r="",limit:o,prefix:s,startKey:i,startExclusive:a,startSecondaryKey:l}=t.options;if(e!==r)return!1;if(!r)return o!==void 0&&o<=0?!1:!s&&!i?!0:!(s&&(!n.startsWith(s)||Hi(t,n))||i&&(a&&Dn(n,i)||gn(n,i)||Hi(t,n)));if(!s&&!i&&!l)return!0;let[u,c]=qe(n);return!(s&&!u.startsWith(s)||l&&(a&&Dn(u,l)||gn(u,l))||i&&(a&&Dn(c,i)||gn(c,i)))}function Hi(t,e){let{inclusiveLimitKey:n}=t;return t.options.limit!==void 0&&n!==void 0&&Pe(e,n)}function*Eu(t,e){for(let n of t)n.matches(e)&&(yield n)}function Tu(t,e,n){if(e==="")return!0;let r=n?s=>qe(s.key)[0]:s=>s.key,o=Ei(t,e,r);return o<t.length&&r(t[o]).startsWith(e)}function Ei(t,e,n){return Sn(t.length,r=>Me(e,n(t[r])))}var xo="";function Lu(){if(xo===""){let t=new Uint8Array(4);crypto.getRandomValues(t),xo=Array.from(t,e=>e.toString(16)).join("")}return xo}var Ro=new Map;function ko(t){let e=Ro.get(t);return e?(e++,Ro.set(t,e)):(Ro.set(t,0),e=0),`${t}-${Lu()}-${e}`}var Mo="15.0.1";var Fu=8,ju=1e3,Ju=1e3,zu=500,Gu=500,Uu=100*2**20,_u=5*60*1e3,Ku=24*60*60*1e3,Bu=5*60*1e3,or=()=>{},qu={type:"NewClientGroup"},Wu=(t,e)=>new rr(t,e),sr=class{pullURL;pushURL;auth;name;subscriptions;#e;isClientGroupDisabled=!1;#t;lastMutationID=0;get idbName(){return ir(this.name,this.schemaVersion)}schemaVersion;get#n(){return{name:this.idbName,replicacheName:this.name,replicacheFormatVersion:7,schemaVersion:this.schemaVersion}}#r=!1;#o=!0;#i=pe();#a;#u;#l;licenseCheckPromise;licenseActivePromise;#p=null;#c={};mutate;#y=0;#P=0;#S;#g;pullInterval;pushDelay;#v;puller;pusher;#d;memdag;perdag;#h;#s;#m=new AbortController;#I=!1;#N;#O;#V;#U=new Bt(()=>this.persist(),ju,zu,this.#m.signal);#H;#_=new Bt(()=>this.refresh(),Ju,Gu,this.#m.signal);#b;get requestOptions(){return this.#v}onSync=null;onClientStateNotFound=Li;onUpdateNeeded=Li;getAuth=null;onPushInvoked=()=>{};onBeginPull=()=>{};onRecoverMutations=e=>e;constructor(e,n={}){let{name:r,logLevel:o="info",logSinks:s=[Au],pullURL:i="",auth:a,pushDelay:l=10,pushURL:u="",schemaVersion:c="",pullInterval:d=6e4,mutators:p={},requestOptions:m={},puller:g,pusher:y,licenseKey:S,indexes:D={}}=e,{enableMutationRecovery:b=!0,enableLicensing:I=!0,enableScheduledPersist:C=!0,enableScheduledRefresh:P=!0,enablePullAndPushInOpen:w=!0,makeSubscriptionsManager:O=Wu,enableClientGroupForking:k=!0}=n;if(this.auth=a??"",this.pullURL=i,this.pushURL=u,typeof r!="string"||!r)throw new TypeError("name is required and must be non-empty");this.name=r,this.schemaVersion=c,this.pullInterval=d,this.pushDelay=l,this.puller=g??Dr(this),this.pusher=y??ri(this),this.#b=I,this.#N=C,this.#O=P,this.#V=w,this.#s=Gt(o,s,{name:r}),this.#s.debug?.("Constructing Replicache",{name:r,"replicache version":Mo}),this.subscriptions=O(this.#G,this.#s);let x=qt(this.#s,e.kvStore);this.#t=x;let J=x.create(this.idbName);this.#h=new Ee(x.create),this.perdag=new Se(J,G,q),this.memdag=new Te(this.perdag,Uu,G,q);let z=it();this.#a=z.promise,this.#d=S;let te=it();this.licenseCheckPromise=te.promise;let at=it();this.licenseActivePromise=at.promise;let{minDelayMs:Wt=Ys,maxDelayMs:$t=Xs}=m;this.#v={maxDelayMs:$t,minDelayMs:Wt};let Gi=Ws(Lt(),0,this.#m.signal);this.#S=new At(this.#s.withContext("PULL"),new Kn(this,()=>this.#W()),Gi),this.#g=new At(this.#s.withContext("PUSH"),new Bn(this,()=>this.#$())),this.mutate=this.#Q(p);let No=it();this.#u=No.promise;let Oo=it();this.#l=Oo.promise,this.#e=new Zn({delegate:this,lc:this.#s,enableMutationRecovery:b,wrapInOnlineCheck:this.#w.bind(this),wrapInReauthRetries:this.#x.bind(this),isPullDisabled:this.#L.bind(this),isPushDisabled:this.#A.bind(this),clientGroupIDPromise:this.#l}),this.#H=yi(this.name,this.#m.signal,Ui=>{this.#Y(Ui)}),this.#K(D,k,No.resolve,Oo.resolve,z.resolve,te.resolve,at.resolve)}async#K(e,n,r,o,s,i,a){let{clientID:l}=this;await Po.get(this.name),await this.#h.getProfileID().then(r),await this.#h.putDatabase(this.#n);let[u,c,d,p]=await As(l,this.#s,this.perdag,Object.keys(this.#c),e,7,n);o(u.clientGroupID),await v(this.memdag,g=>g.setHead(N,c)),s(),await this.#B(i),this.#V&&(this.pull().catch(or),this.push().catch(or));let{signal:m}=this.#m;wi(l,this.perdag,()=>{this.#D(l)},this.#s,m),Si(l,this.perdag,this.#s,m),Fi(this.#h,this.#s,m,this.#t.drop),bi(this.perdag,this.#s,m),fi(this.name,this.idbName,m,u.clientGroupID,p,()=>{this.#j(qu)},this.perdag),Ni(()=>this.recoverMutations(),_u,m),this.recoverMutations(d),Lt()?.addEventListener("visibilitychange",this.#E),await this.#q(a,this.#s,m)}#E=async()=>{this.#r||Lt()?.visibilityState==="visible"&&await this.#T()};async#T(){let{clientID:e}=this,n=await V(this.perdag,r=>no(e,r));return n||this.#D(e),!n}async#B(e){if(!this.#b){e(!0);return}if(!this.#d){await this.#C(this.#s,"license key ReplicacheOptions.licenseKey is not set",!0,e);return}if(this.#s.debug?.(`Replicache license key: ${this.#d}`),this.#d===ut){this.#s.info?.("Skipping license check for TEST_LICENSE_KEY. You may ONLY use this key for automated (e.g., unit/CI) testing. See https://replicache.dev for more information."),e(!0),this.#p=setTimeout(async()=>{await this.#C(this.#s,"Test key expired",!0,e)},Bu);return}try{let n=await hr(wo,Xt,this.#d,this.#s);if(n.pleaseUpdate&&this.#s.error?.("You are using an old version of Replicache that uses deprecated licensing features. Please update Replicache else it may stop working."),n.status==="VALID")this.#s.debug?.("License is valid.");else{await this.#C(this.#s,`status: ${n.status}`,n.disable,e);return}}catch(n){this.#s.error?.(`Error checking license: ${n}`)}e(!0)}async#C(e,n,r,o){e.error?.(`** REPLICACHE LICENSE NOT VALID ** Replicache license key '${this.#d}' is not valid (${n}). Please run 'npx replicache get-license' to get a license key or contact hello@replicache.dev for help.`),r&&(await this.close(),e.error?.("** REPLICACHE DISABLED **")),o(!1)}async#q(e,n,r){if(!this.#b||!this.#d||this.#d===ut){e(!1);return}let o=async()=>{try{await dr(wo,Xt,this.#d,await this.profileID,n)}catch(s){this.#s.info?.(`Error sending license active ping: ${s}`)}};await o(),e(!0),ae("LicenseActive",o,()=>Ku,n,r)}get profileID(){return this.#u}get clientID(){return this.#i}get clientGroupID(){return this.#l}onOnlineChange=null;get online(){return this.#o}get closed(){return this.#r}async close(){this.#r=!0;let{promise:e,resolve:n}=it();Po.set(this.name,e),this.#m.abort(),Lt()?.removeEventListener("visibilitychange",this.#E),await this.#a;let r=[this.memdag.close(),this.perdag.close(),this.#h.close()];this.#S.close(),this.#g.close(),this.subscriptions.clear(),this.#p&&clearTimeout(this.#p),await Promise.all(r),Po.delete(this.name),n()}async maybeEndPull(e,n){for(;;){if(this.#r)return;await this.#a;let{clientID:r}=this,o=this.#s.withContext("maybeEndPull").withContext("requestID",n),{replayMutations:s,diffs:i}=await ui(this.memdag,o,e,r,this.subscriptions,7);if(!s||s.length===0){await this.subscriptions.fire(i),this.#J();return}for(let a of s){this.subscriptions.hasPendingSubscriptionRuns&&await Promise.resolve();let{meta:l}=a;e=await he(this.memdag,u=>ni(a,u,e,Ae,this.#c,o,Be(l)?l.clientID:r,7))}}}#W(){return this.#L()?Promise.resolve(!0):this.#w(async()=>{try{this.#f(0,1);let{syncHead:e,requestID:n,ok:r}=await this.beginPull();if(!r)return!1;e!==T&&await this.maybeEndPull(e,n)}catch(e){throw await this.#M(e)}finally{this.#f(0,-1)}return!0},"Pull")}#L(){return this.isClientGroupDisabled||this.pullURL===""&&Wo(this.puller)}async#w(e,n){let r=!0;try{return await e()}catch(o){return o instanceof rt||o instanceof Le?(r=!1,this.#s.debug?.(`${n} threw:
+`,t)}async function uu(t,e,n,r,o,s){f(r.replicacheFormatVersion===4),to(t);let{delegate:i,lc:a,wrapInOnlineCheck:l,wrapInReauthRetries:u,isPushDisabled:c,isPullDisabled:d}=o,p=i.clientID;if(p===e||t.lastServerAckdMutationID>=t.mutationID)return;let m=`Recovering mutations for ${e}.`;a.debug?.("Start:",m);let g=new Te(n,hi,vr,q);try{if(await v(g,w=>w.setHead(N,t.headHash)),c()){a.debug?.(`Cannot recover mutations for client ${e} because push is disabled.`);return}let{pusher:y}=i,S="recoveringMutationsPush";if(!await l(async()=>{let{result:w}=await u(async(O,k)=>{mr(g);let x=await Ut(O,g,k,await i.profileID,void 0,e,y,r.schemaVersion,Xn);return{result:x,httpRequestInfo:x?.httpRequestInfo}},S,a);return!!w&&w.httpRequestInfo.httpStatusCode===200},S)){a.debug?.(`Failed to recover mutations for client ${e} due to a push error.`);return}if(d()){a.debug?.(`Cannot confirm mutations were recovered for client ${e} because pull is disabled.`);return}let{puller:b}=i,I="recoveringMutationsPull",C;if(!await l(async()=>{let{result:w}=await u(async(O,k)=>{let x=await ai(await i.profileID,e,r.schemaVersion,b,O,g,s,k,!1);return{result:x,httpRequestInfo:x.httpRequestInfo}},I,a);return{pullResponse:C}=w,!!C&&w.httpRequestInfo.httpStatusCode===200},I)){a.debug?.(`Failed to recover mutations for client ${e} due to a pull error.`);return}return a.debug&&C&&(U(C)?a.debug?.(`Client ${p} cannot recover mutations for client ${e}. The client no longer exists on the server.`):K(C)?a.debug?.(`Version is not supported on the server. versionType: ${C.versionType}. Cannot recover mutations for client ${e}.`):a.debug?.(`Client ${p} recovered mutations for client ${e}.  Details`,{mutationID:t.mutationID,lastServerAckdMutationID:t.lastServerAckdMutationID,lastMutationID:C.lastMutationID})),await v(n,async w=>{let O=await W(w),k=O.get(e);if(!k)return O;to(k);let x=async z=>(await ye(z,w),z);if(U(C)||K(C)){let z=new Map(O);return z.delete(e),x(z)}if(f(C),k.lastServerAckdMutationID>=C.lastMutationID)return O;let J=new Map(O).set(e,{...k,lastServerAckdMutationID:C.lastMutationID});return x(J)})}catch(y){_t(y,a,m,i)}finally{await g.close(),a.debug?.("End:",m)}}async function cu(t,e,n,r){let o=r(t.name),s=new Se(o,G,q);try{await mi(t,e,s,n)}finally{await s.close()}}function mi(t,e,n,r){return t.replicacheFormatVersion>=5?du(t,e,n):pu(t,e,n,r)}async function pu(t,e,n,r){let{delegate:o,lc:s}=e,i=`Recovering mutations from db ${t.name}.`;s.debug?.("Start:",i);try{let a=Hr(t.replicacheFormatVersion),l=r||await V(n,c=>W(c)),u=new Set;for(;l;){let c;for(let[d,p]of l){if(o.closed){s.debug?.("Exiting early due to close:",i);return}if(!u.has(d)&&(u.add(d),c=await uu(p,d,n,t,e,a),c))break}l=c}}catch(a){_t(a,s,i,o)}s.debug?.("End:",i)}async function du(t,e,n){let{delegate:r,lc:o}=e,s=`Recovering mutations from db ${t.name}.`;o.debug?.("Start:",s);try{let i=Hr(t.replicacheFormatVersion),a=await V(n,u=>ee(u)),l=new Set;for(;a;){let u;for(let[c,d]of a){if(r.closed){o.debug?.("Exiting early due to close:",s);return}if(!l.has(c)&&(l.add(c),u=await hu(d,c,n,t,e,i),u))break}a=u}}catch(i){_t(i,o,s,r)}o.debug?.("End:",s)}function pi(t){return U(t)||K(t)}async function di(t,e,n,r,o){U(r)?t.debug?.(`Client group ${e} cannot recover mutations for client group ${n}. The client group is unknown on the server. Marking it as disabled.`):K(r)&&t.debug?.(`Client group ${e} cannot recover mutations for client group ${n}. The client group's version is not supported on the server. versionType: ${r.versionType}. Marking it as disabled.`),await v(o,s=>yn(n,s))}async function hu(t,e,n,r,o,s){f(r.replicacheFormatVersion>=5);let{delegate:i,lc:a,wrapInOnlineCheck:l,wrapInReauthRetries:u,isPushDisabled:c,isPullDisabled:d}=o,p=await o.clientGroupIDPromise;if(mr(p),p===e)return;let m,g=!0;for(let[D,b]of Object.entries(t.mutationIDs))if(!t.lastServerAckdMutationIDs[D]||t.lastServerAckdMutationIDs[D]<b){m=D,g=!1;break}if(g)return;if(t.disabled){a.debug?.(`Not recovering mutations for client group ${e} because group is disabled.`);return}let y=`Recovering mutations for client group ${e}.`;a.debug?.("Start:",y);let S=new Te(n,hi,vr,q);try{if(await v(S,k=>k.setHead(N,t.headHash)),c()){a.debug?.(`Cannot recover mutations for client group ${e} because push is disabled.`);return}let{pusher:D}=i,b="recoveringMutationsPush";if(!await l(async()=>{let{result:k}=await u(async(J,z)=>{f(m),f(S);let te=await Ut(J,S,z,await i.profileID,e,m,D,r.schemaVersion,ot);return{result:te,httpRequestInfo:te?.httpRequestInfo}},b,a);if(!k)return!1;let x=k.response;return pi(x)?(await di(a,p,e,x,n),!1):k.httpRequestInfo.httpStatusCode===200},b)){a.debug?.(`Failed to recover mutations for client ${e} due to a push error.`);return}if(d()){a.debug?.(`Cannot confirm mutations were recovered for client ${e} because pull is disabled.`);return}let{puller:C}=i,P="recoveringMutationsPull",w;if(!await l(async()=>{let{result:k}=await u(async(J,z)=>{f(m);let te=await Yn(await i.profileID,m,e,r.schemaVersion,C,J,S,s,z,!1);return{result:te,httpRequestInfo:te.httpRequestInfo}},P,a),{pullResponse:x}=k;return pi(x)?(await di(a,p,e,x,n),!1):!x||k.httpRequestInfo.httpStatusCode!==200?!1:(w=x,!0)},P)){a.debug?.(`Failed to recover mutations for client ${e} due to a pull error.`);return}return f(w),a.debug?.(`Client group ${p} recovered mutations for client group ${e}.  Details`,{mutationIDs:t.mutationIDs,lastServerAckdMutationIDs:t.lastServerAckdMutationIDs,lastMutationIDChanges:w.lastMutationIDChanges}),await v(n,async k=>{let x=await ee(k),J=x.get(e);if(!J)return x;f(w);let z={},te=!1;for(let[Wt,$t]of Object.entries(w.lastMutationIDChanges))(J.lastServerAckdMutationIDs[Wt]??0)<$t&&(z[Wt]=$t,te=!0);if(!te)return x;let at=new Map(x).set(e,{...J,lastServerAckdMutationIDs:{...J.lastServerAckdMutationIDs,...z}});return await mn(at,k),at})}catch(D){_t(D,a,y,i)}finally{await S.close(),a.debug?.("End:",y)}}var Co=class{name;onmessage=null;onmessageerror=null;constructor(e){this.name=e}addEventListener(){}removeEventListener(){}dispatchEvent(){return!1}close(){}postMessage(){}},Kt=typeof BroadcastChannel>"u"?Co:BroadcastChannel;function mu(t){return`replicache-new-client-group:${t}`}function fu(t){return`replicache-new-client-group-v1:${t}`}function yu(t){return typeof t=="object"&&typeof t.clientGroupID=="string"&&typeof t.idbName=="string"}function fi(t,e,n,r,o,s,i){if(n.aborted)return;let a=new Kt(fu(t));if(o){a.postMessage({clientGroupID:r,idbName:e});let l=new Kt(mu(t));l.postMessage([r]),l.close()}a.onmessage=async l=>{let{data:u}=l;if(yu(u)){let{clientGroupID:c,idbName:d}=u;if(c!==r)if(d===e)await V(i,async m=>await ke(c,m)!==void 0)&&s();else{s();return}}},n.addEventListener("abort",()=>a.close())}function gu(t){return`replicache-on-persist:${t}`}function Du(t){M(t),R(t.clientGroupID),R(t.clientID)}function yi(t,e,n){if(e.aborted)return()=>{};let r=new Kt(gu(t));return r.onmessage=o=>{let{data:s}=o;Du(s),n({clientGroupID:s.clientGroupID,clientID:s.clientID})},e.addEventListener("abort",()=>{r.close()}),o=>{e.aborted||(r.postMessage(o),n(o))}}async function gi(t){let e=await ze(N,t);return(await On(e,t)).map(r=>({id:r.meta.mutationID,name:r.meta.mutatorName,args:r.meta.mutatorArgsJSON,clientID:r.meta.clientID})).reverse()}var Su=7*24*60*60*1e3,Iu=5*60*1e3,Di;function Si(t,e,n,r){ae("ClientGC",()=>(Di=bu(t,e),Di),()=>Iu,n,r)}function bu(t,e){return v(e,async n=>{let r=Date.now(),o=await W(n),s=Array.from(o).filter(([a,l])=>a===t||r-l.heartbeatTimestampMs<=Su);if(s.length===o.size)return o;let i=new Map(s);return await ye(i,n),i})}var Cu=5*60*1e3,Ii;function bi(t,e,n){ae("ClientGroupGC",()=>(Ii=wu(t),Ii),()=>Cu,e,n)}function wu(t){return v(t,async e=>{let n=await W(e),r=new Set;for(let s of n.values())$e(s),r.add(s.clientGroupID);let o=new Map;for(let[s,i]of await ee(e))(r.has(s)||fn(i))&&o.set(s,i);return await mn(o,e),o})}var xu=60*1e3,Ci;function wi(t,e,n,r,o){ae("Heartbeat",async()=>{Ci=Ru(t,e);try{return await Ci}catch(s){if(s instanceof Y){n();return}throw s}},()=>xu,r,o)}function Ru(t,e){return v(e,async n=>{let r=await W(n),o=r.get(t);if(!o)throw new Y(t);let s={...o,heartbeatTimestampMs:Date.now()},i=new Map(r).set(t,s);return await ye(i,n),i})}var st=class{#e=new Set;#t;constructor(e){this.#t=e}async visit(e){if(this.#e.has(e))return;this.#e.add(e);let n=await this.#t.mustGetChunk(e);await this.visitChunk(n)}async visitChunk(e){await Promise.all(e.meta.map(n=>this.visit(n)))}};var Qn=class extends st{#e=new Map;#t;constructor(e){super(e),this.#t=e}get gatheredChunks(){return this.#e}visit(e){return this.#t.isMemOnlyChunkHash(e)?super.visit(e):A}visitChunk(e){return this.#e.set(e.hash,e),super.visitChunk(e)}};async function ki(t,e,n,r,o,s,i,a=()=>Promise.resolve()){if(s())return;let[l,u,c]=await V(r,async y=>{await Ls(e,y);let S=await oo(e,y);f(S,`No main client group for clientID: ${e}`);let[,D]=await xi(y,S),b=await D.getMutationID(e,y),I=await Ve(D,y);return ue(I),[b,I,S]});if(s())return;let[d,p,m]=await V(n,async y=>{let S=await Ke(N,y),D=await Vn(S,{[e]:l||0},y),b=await Ve(S,y);ue(b);let I;if(kt(b,u)>0){await a();let C=b.chunk.hash,P=new Qn(y);await P.visit(C),I=P.gatheredChunks}return[D,b,I]});if(s())return;let g=!1;await v(r,async y=>{let[S,D]=await xi(y,c),b=D.chunk.hash,I={...S.mutationIDs},{lastServerAckdMutationIDs:C}=S;if(m){let w=await Et(e,y);$e(w);let O=await Ve(D,y);if(ue(O),kt(p,O)>0){g=!0,await Promise.all(Array.from(m.values(),x=>y.putChunk(x))),await Tt(e,{...w,persistHash:p.chunk.hash},y),b=p.chunk.hash;let k=await On(S.headHash,y);C=p.meta.lastMutationIDs,I={...C},b=await Ri(k,b,y,o,I,t,i)}}b=await Ri(d,b,y,o,I,t,i);let P={...S,headHash:b,mutationIDs:I,lastServerAckdMutationIDs:C};await Dt(c,P,y)}),m&&g&&await v(n,y=>y.chunksPersisted([...m.keys()]))}async function xi(t,e){let n=await ke(e,t);return f(n,`No client group for clientGroupID: ${e}`),[n,await H(n.headHash,t)]}async function Ri(t,e,n,r,o,s,i){for(let a=t.length-1;a>=0;a--){let l=t[a],{meta:u}=l,c=await H(e,n);await l.getMutationID(u.clientID,n)>await c.getMutationID(u.clientID,n)&&(o[u.clientID]=u.mutationID,e=(await $n(l,n,e,r,s,u.clientID,i)).chunk.hash)}return e}var er=class extends st{#e=new Map;#t=0;#n;#r;#o;constructor(e,n,r,o=fe){super(e),this.#n=n,this.#r=r,this.#o=o}get gatheredChunks(){return this.#e}visit(e){return this.#t>=this.#r||this.#n.isCached(e)?A:super.visit(e)}visitChunk(e){if(this.#t<this.#r){let n=this.#o(e);this.#e.set(e.hash,{chunk:e,size:n}),this.#t+=n}return super.visitChunk(e)}};var ku=5*2**20,Mu=300;async function Pi(t,e,n,r,o,s,i,a){if(i())return;let l=await V(e,d=>ms(N,d));ue(l);let u=await e.withSuspendedSourceCacheEvictsAndDeletes(async()=>{let d=await v(n,async D=>{let b=await zs(r,D);if(!b)throw new Y(r);let I=b.headHash,P=await(await H(I,D)).getMutationID(r,D),w=await Et(r,D);$e(w);let O=await B(I,D);if(ue(O),Mi(l,O,I))return;let k=new er(D,e,ku);await k.visit(I);let{gatheredChunks:x}=k,J=new Set(w.refreshHashes);J.add(I);let z={...w,refreshHashes:[...J]};return await Tt(r,z,D),[I,O,P,x,w.refreshHashes]});if(i()||!d)return{type:"aborted"};if(await ce(Mu),i())return{type:"aborted"};let[p,m,g,y,S]=d;return v(e,async D=>{let b=await Ke(N,D),I=await Ve(b,D);if(ue(I),Mi(I,m,p))return{type:"aborted",refreshHashesForRevert:S};let C=await Vn(b,{[r]:g},D),P=[];for(let{chunk:x,size:J}of y.values())P.push(D.putChunk(x,J));await Promise.all(P);let w=p;for(let x=C.length-1;x>=0;x--)w=(await $n(C[x],D,w,o,t,C[x].meta.clientID,a)).chunk.hash;let O=await H(w,D),k=await Ps(b,O,D,s,a);return await D.setHead(N,w),{type:"complete",diffs:k,newPerdagClientHeadHash:p}})});if(i())return;let c=d=>v(n,async p=>{let g={...await Et(r,p),refreshHashes:d};await Tt(r,g,p)});if(u.type==="aborted"){u.refreshHashesForRevert&&await c(u.refreshHashesForRevert);return}return await c([u.newPerdagClientHeadHash]),u.diffs}function Mi(t,e,n){let r=kt(t,e);return r>0||r===0&&n===e.chunk.hash}import{resolver as Pu}from"@rocicorp/resolver";function vi(t){return new Promise(e=>{typeof requestIdleCallback=="function"?requestIdleCallback(()=>e(),{timeout:t}):setTimeout(()=>e(),t)})}var Bt=class{#e;#t;#n;#r;#o;#i=void 0;#a=void 0;#u=Promise.resolve();#l=Promise.resolve();constructor(e,n,r,o,s=vi){this.#e=e,this.#t=n,this.#n=r,this.#r=o,this.#o=s,this.#r.addEventListener("abort",()=>{let i=new Z("Aborted");this.#a?.reject(i),this.#i?.reject(i),this.#a=void 0,this.#i=void 0})}schedule(){return this.#r.aborted?Promise.reject(new Z("Aborted")):this.#i?this.#i.promise:(this.#i=Pu(),this.#p(),this.#i.promise)}async#p(){try{await this.#u}catch{}if(await this.#l,!!this.#i&&(await this.#o(this.#t),!!this.#i)){this.#l=vu(this.#n,this.#r),this.#a=this.#i,this.#i=void 0;try{this.#u=this.#e(),await this.#u,this.#a?.resolve()}catch(e){this.#a?.reject(e)}this.#a=void 0}}};async function vu(t,e){try{await ce(t,e)}catch(n){f(n instanceof Z)}}function Ni(t,e,n){if(!n.aborted){let r=setInterval(t,e);n.addEventListener("abort",()=>{clearInterval(r)})}}async function wo(t,e,n,r){let o=await fetch(e,{method:t,body:n,headers:r});if(!o.ok)throw new Error(`Got ${o.status} fetching ${e}: ${await o.text()}`);return o}var Nu=new Set,Oi=Symbol(),tr=class{#e;#t;#n=Oi;#r=Nu;#o=[];onError;onDone;#i;constructor(e,n,r,o,s=$){this.#e=e,this.#t=n,this.onError=r,this.onDone=o,this.#i=s}hasIndexSubscription(e){for(let n of this.#o)if(n.options.indexName===e)return!0;return!1}invoke(e,n,r){return this.#e(e)}matches(e){for(let[n,r]of e)if(Ou(this.#r,this.#o,n,r))return!0;return!1}updateDeps(e,n){this.#r=e,this.#o=n}onData(e){(this.#n===Oi||!this.#i(this.#n,e))&&(this.#n=e,this.#t(e))}};var nr=class{#e;#t;#n;#r;onError=void 0;onDone=void 0;constructor(e,n){this.#e=e,this.#t=n?.prefix??"",this.#n=n?.indexName,this.#r=n?.initialValuesInFirstDiff??!1}hasIndexSubscription(e){return this.#n===e}onData(e){e!==void 0&&this.#e(e)}invoke(e,n,r){let o=async(s,i,a,l)=>{let u;if(n===0){if(!this.#r)return;f(r===void 0);let p=[];for await(let m of e.scan({prefix:i,indexName:s}).entries())p.push({op:"add",key:m[0],newValue:m[1]});u=p}else{f(r);let p=r.get(s??"")??[];u=l(p)}let c=[],{length:d}=u;for(let p=Ei(u,i,a);p<d&&a(u[p]).startsWith(i);p++)c.push(u[p]);return n===0||c.length>0?c:void 0};return this.#n?o(this.#n,this.#t,s=>s.key[0],s=>Vi(s,qe)):o(void 0,this.#t,s=>s.key,s=>Vi(s,i=>i))}matches(e){let n=e.get(this.#n??"");return n===void 0?!1:Tu(n,this.#t,this.#n)}updateDeps(e,n){}};function Vi(t,e){return t.map(n=>{let r=e(n.key);switch(n.op){case"add":return{op:"add",key:r,newValue:n.newValue};case"change":return{op:"change",key:r,oldValue:n.oldValue,newValue:n.newValue};case"del":return{op:"del",key:r,oldValue:n.oldValue}}})}var rr=class{#e=new Set;#t=new Set;#n;#r;hasPendingSubscriptionRuns=!1;constructor(e,n){this.#n=e,this.#r=n}add(e){return this.#e.add(e),this.#i(e),()=>this.#e.delete(e)}clear(){for(let e of this.#e)e.onDone?.();this.#e.clear()}async fire(e){let n=Eu(this.#e,e);await this.#o(n,1,e)}async#o(e,n,r){let o=[...e];if(o.length===0)return;let s=await this.#n(i=>Promise.allSettled(o.map(async a=>{let l=new Wn(i);try{return await a.invoke(l,n,r)}finally{a.updateDeps(l.keys,l.scans)}})));this.callCallbacks(o,s)}callCallbacks(e,n){for(let r=0;r<e.length;r++){let o=e[r],s=n[r];s.status==="fulfilled"?o.onData(s.value):o.onError?o.onError(s.reason):this.#r.error?.("Error in subscription body:",s.reason)}}async#i(e){if(this.#t.add(e),!this.hasPendingSubscriptionRuns){this.hasPendingSubscriptionRuns=!0,await Promise.resolve(),this.hasPendingSubscriptionRuns=!1;let n=[...this.#t];this.#t.clear(),await this.#o(n,0,void 0)}}shouldComputeDiffs(){return this.#e.size>0}shouldComputeDiffsForIndex(e){for(let n of this.#e)if(n.hasIndexSubscription(e))return!0;return!1}};function Ou(t,e,n,r){if(n===""){for(let o of r)if(t.has(o.key))return!0}for(let o of e)if(Vu(o,n,r))return!0;return!1}function Vu(t,e,n){for(let r of n)if(Hu(t,e,r.key))return!0;return!1}function Hu(t,e,n){let{indexName:r="",limit:o,prefix:s,startKey:i,startExclusive:a,startSecondaryKey:l}=t.options;if(e!==r)return!1;if(!r)return o!==void 0&&o<=0?!1:!s&&!i?!0:!(s&&(!n.startsWith(s)||Hi(t,n))||i&&(a&&Dn(n,i)||gn(n,i)||Hi(t,n)));if(!s&&!i&&!l)return!0;let[u,c]=qe(n);return!(s&&!u.startsWith(s)||l&&(a&&Dn(u,l)||gn(u,l))||i&&(a&&Dn(c,i)||gn(c,i)))}function Hi(t,e){let{inclusiveLimitKey:n}=t;return t.options.limit!==void 0&&n!==void 0&&Pe(e,n)}function*Eu(t,e){for(let n of t)n.matches(e)&&(yield n)}function Tu(t,e,n){if(e==="")return!0;let r=n?s=>qe(s.key)[0]:s=>s.key,o=Ei(t,e,r);return o<t.length&&r(t[o]).startsWith(e)}function Ei(t,e,n){return Sn(t.length,r=>Me(e,n(t[r])))}var xo="";function Lu(){if(xo===""){let t=new Uint8Array(4);crypto.getRandomValues(t),xo=Array.from(t,e=>e.toString(16)).join("")}return xo}var Ro=new Map;function ko(t){let e=Ro.get(t);return e?(e++,Ro.set(t,e)):(Ro.set(t,0),e=0),`${t}-${Lu()}-${e}`}var Mo="15.0.1";var Fu=8,ju=1e3,Ju=1e3,zu=500,Gu=500,Uu=100*2**20,_u=5*60*1e3,Ku=24*60*60*1e3,Bu=5*60*1e3,or=()=>{},qu={type:"NewClientGroup"},Wu=(t,e)=>new rr(t,e),sr=class{pullURL;pushURL;auth;name;subscriptions;#e;isClientGroupDisabled=!1;#t;lastMutationID=0;get idbName(){return ir(this.name,this.schemaVersion)}schemaVersion;get#n(){return{name:this.idbName,replicacheName:this.name,replicacheFormatVersion:7,schemaVersion:this.schemaVersion}}#r=!1;#o=!0;#i=pe();#a;#u;#l;licenseCheckPromise;licenseActivePromise;#p=null;#c={};mutate;#y=0;#P=0;#S;#g;pullInterval;pushDelay;#v;puller;pusher;#d;memdag;perdag;#h;#s;#m=new AbortController;#I=!1;#N;#O;#V;#U=new Bt(()=>this.persist(),ju,zu,this.#m.signal);#H;#_=new Bt(()=>this.refresh(),Ju,Gu,this.#m.signal);#b;get requestOptions(){return this.#v}onSync=null;onClientStateNotFound=Li;onUpdateNeeded=Li;getAuth=null;onPushInvoked=()=>{};onBeginPull=()=>{};onRecoverMutations=e=>e;constructor(e,n={}){let{name:r,logLevel:o="info",logSinks:s=[Au],pullURL:i="",auth:a,pushDelay:l=10,pushURL:u="",schemaVersion:c="",pullInterval:d=6e4,mutators:p={},requestOptions:m={},puller:g,pusher:y,licenseKey:S,indexes:D={}}=e,{enableMutationRecovery:b=!0,enableLicensing:I=!0,enableScheduledPersist:C=!0,enableScheduledRefresh:P=!0,enablePullAndPushInOpen:w=!0,makeSubscriptionsManager:O=Wu,enableClientGroupForking:k=!0}=n;if(this.auth=a??"",this.pullURL=i,this.pushURL=u,typeof r!="string"||!r)throw new TypeError("name is required and must be non-empty");this.name=r,this.schemaVersion=c,this.pullInterval=d,this.pushDelay=l,this.puller=g??Dr(this),this.pusher=y??ri(this),this.#b=I,this.#N=C,this.#O=P,this.#V=w,this.#s=Gt(o,s,{name:r}),this.#s.debug?.("Constructing Replicache",{name:r,"replicache version":Mo}),this.subscriptions=O(this.#G,this.#s);let x=qt(this.#s,e.kvStore);this.#t=x;let J=x.create(this.idbName);this.#h=new Ee(x.create),this.perdag=new Se(J,G,q),this.memdag=new Te(this.perdag,Uu,G,q);let z=it();this.#a=z.promise,this.#d=S;let te=it();this.licenseCheckPromise=te.promise;let at=it();this.licenseActivePromise=at.promise;let{minDelayMs:Wt=Ys,maxDelayMs:$t=Xs}=m;this.#v={maxDelayMs:$t,minDelayMs:Wt};let Gi=Ws(Lt(),0,this.#m.signal);this.#S=new At(this.#s.withContext("PULL"),new Kn(this,()=>this.#W()),Gi),this.#g=new At(this.#s.withContext("PUSH"),new Bn(this,()=>this.#$())),this.mutate=this.#Q(p);let No=it();this.#u=No.promise;let Oo=it();this.#l=Oo.promise,this.#e=new Zn({delegate:this,lc:this.#s,enableMutationRecovery:b,wrapInOnlineCheck:this.#w.bind(this),wrapInReauthRetries:this.#x.bind(this),isPullDisabled:this.#L.bind(this),isPushDisabled:this.#A.bind(this),clientGroupIDPromise:this.#l}),this.#H=yi(this.name,this.#m.signal,Ui=>{this.#Y(Ui)}),this.#K(D,k,No.resolve,Oo.resolve,z.resolve,te.resolve,at.resolve)}async#K(e,n,r,o,s,i,a){let{clientID:l}=this;await Po.get(this.name),await this.#h.getProfileID().then(r),await this.#h.putDatabase(this.#n);let[u,c,d,p]=await As(l,this.#s,this.perdag,Object.keys(this.#c),e,7,n);o(u.clientGroupID),await v(this.memdag,g=>g.setHead(N,c)),s(),await this.#B(i),this.#V&&(this.pull().catch(or),this.push().catch(or));let{signal:m}=this.#m;wi(l,this.perdag,()=>{this.#D(l)},this.#s,m),Si(l,this.perdag,this.#s,m),Fi(this.#h,this.#s,m,this.#t.drop),bi(this.perdag,this.#s,m),fi(this.name,this.idbName,m,u.clientGroupID,p,()=>{this.#j(qu)},this.perdag),Ni(()=>this.recoverMutations(),_u,m),this.recoverMutations(d),Lt()?.addEventListener("visibilitychange",this.#E),await this.#q(a,this.#s,m)}#E=async()=>{this.#r||Lt()?.visibilityState==="visible"&&await this.#T()};async#T(){let{clientID:e}=this,n=await V(this.perdag,r=>no(e,r));return n||this.#D(e),!n}async#B(e){if(!this.#b){e(!0);return}if(!this.#d){await this.#C(this.#s,"license key ReplicacheOptions.licenseKey is not set",!0,e);return}if(this.#s.debug?.(`Replicache license key: ${this.#d}`),this.#d===ut){this.#s.info?.("Skipping license check for TEST_LICENSE_KEY. You may ONLY use this key for automated (e.g., unit/CI) testing. See https://replicache.dev for more information."),e(!0),this.#p=setTimeout(async()=>{await this.#C(this.#s,"Test key expired",!0,e)},Bu);return}try{let n=await hr(wo,Xt,this.#d,this.#s);if(n.pleaseUpdate&&this.#s.error?.("You are using an old version of Replicache that uses deprecated licensing features. Please update Replicache else it may stop working."),n.status==="VALID")this.#s.debug?.("License is valid.");else{await this.#C(this.#s,`status: ${n.status}`,n.disable,e);return}}catch(n){this.#s.error?.(`Error checking license: ${n}`)}e(!0)}async#C(e,n,r,o){e.error?.(`** REPLICACHE LICENSE NOT VALID ** Replicache license key '${this.#d}' is not valid (${n}). Please run 'npx replicache get-license' to get a license key or contact hello@replicache.dev for help.`),r&&(await this.close(),e.error?.("** REPLICACHE DISABLED **")),o(!1)}async#q(e,n,r){if(!this.#b||!this.#d||this.#d===ut){e(!1);return}let o=async()=>{try{await dr(wo,Xt,this.#d,await this.profileID,n)}catch(s){this.#s.info?.(`Error sending license active ping: ${s}`)}};await o(),e(!0),ae("LicenseActive",o,()=>Ku,n,r)}get profileID(){return this.#u}get clientID(){return this.#i}get clientGroupID(){return this.#l}onOnlineChange=null;get online(){return this.#o}get closed(){return this.#r}async close(){this.#r=!0;let{promise:e,resolve:n}=it();Po.set(this.name,e),this.#m.abort(),Lt()?.removeEventListener("visibilitychange",this.#E),await this.#a;let r=[this.memdag.close(),this.perdag.close(),this.#h.close()];this.#S.close(),this.#g.close(),this.subscriptions.clear(),this.#p&&clearTimeout(this.#p),await Promise.all(r),Po.delete(this.name),n()}async maybeEndPull(e,n){for(;;){if(this.#r)return;await this.#a;let{clientID:r}=this,o=this.#s.withContext("maybeEndPull").withContext("requestID",n),{replayMutations:s,diffs:i}=await ui(this.memdag,o,e,r,this.subscriptions,7);if(!s||s.length===0){await this.subscriptions.fire(i),this.#J();return}for(let a of s){this.subscriptions.hasPendingSubscriptionRuns&&await Promise.resolve();let{meta:l}=a;e=await he(this.memdag,u=>ni(a,u,e,Ae,this.#c,o,Be(l)?l.clientID:r,7))}}}#W(){return this.#L()?Promise.resolve(!0):this.#w(async()=>{try{this.#f(0,1);let{syncHead:e,requestID:n,ok:r}=await this.beginPull();if(!r)return!1;e!==T&&await this.maybeEndPull(e,n)}catch(e){throw await this.#M(e)}finally{this.#f(0,-1)}return!0},"Pull")}#L(){return this.isClientGroupDisabled||this.pullURL===""&&Wo(this.puller)}async#w(e,n){let r=!0;try{return await e()}catch(o){return o instanceof rt||o instanceof Le?(r=!1,this.#s.debug?.(`${n} threw:
 `,o,`
 with cause:
 `,o.causedBy)):o instanceof we?this.#s.error?.(o):this.#s.info?.(`${n} threw:

diff --git a/out/replicache.js b/out/replicache.js
index 11498dc6aa6954d8a3741cdbd14093366e8ac3a8..f35fcfc736ac5b109e88c0109a7d7f0fe7feccf8 100644
--- a/out/replicache.js
+++ b/out/replicache.js
@@ -1,4 +1,4 @@
-var xr=Object.defineProperty;var Vi=Object.getOwnPropertyDescriptor;var Oi=Object.getOwnPropertyNames;var Ei=Object.prototype.hasOwnProperty;var Ti=(t,e)=>{for(var n in e)xr(t,n,{get:e[n],enumerable:!0})},wr=(t,e,n,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Oi(e))!Ei.call(t,r)&&r!==n&&xr(t,r,{get:()=>e[r],enumerable:!(o=Vi(e,r))||o.enumerable});return t},_=(t,e,n)=>(wr(t,e,"default"),n&&wr(n,e,"default"));var br="1.0",Qu=parseInt(br.split(".")[1],10);var Zn="/api/"+br,Qn="/api/:apiMajor.:apiMinor",Ai=Zn+"/customer",ec=Qn+"/customer",Rr=Zn+"/license/status",tc=Qn+"/license/status",kr=Zn+"/license/active",nc=Qn+"/license/active",st="/admin",oc=st+"/download",rc=st+"/license/:key",sc=st+"/licenses/active",ic=st+"/signups",ac=st+"/populate";function eo(t){no(t,"string")}function to(t){no(t,"boolean")}function no(t,e){typeof t!==e&&Pr(t,e)}function qt(t){t===null&&Pr(t,"object"),no(t,"object")}function Fi(t,e){let n="Invalid type: ";return t==null?n+=t:n+=`${typeof t} \`${t}\``,n+`, expected ${e}`}function Pr(t,e){throw new Error(Fi(t,e))}var mc=new URL("https://replicache-license.herokuapp.com/");async function oo(t,e,n,o,r){r=r.withContext("licenseActive");let s=new URL(kr,e),a=JSON.stringify({licenseKey:n,profileID:o});r.debug?.(`Sending ${s}`,a);let u=await(await t("post",s.toString(),a,{"Content-Type":"application/json",Accept:"application/json"})).text();r.debug?.(`Got ${s}`,u);let c=JSON.parse(u);Li(c)}async function ro(t,e,n,o){o=o.withContext("getLicenseStatus");let r=new URL(Rr,e),i=JSON.stringify({licenseKey:n});o.debug?.(`Sending ${r}`,i);let l=await(await t("post",r.toString(),i,{"Content-Type":"application/json",Accept:"application/json"})).text();o.debug?.(`Got ${r}`,l);let u=JSON.parse(l);return ji(u),u}function Li(t){qt(t)}function ji(t){qt(t),eo(t.status),to(t.disable),to(t.pleaseUpdate)}var it="This key only good for automated testing",zi=new URL("http://localhost:8080/"),Wt=new URL("https://replicache-license.herokuapp.com/"),Ji=new URL("https://replicache-license-staging.herokuapp.com/");import{consoleLogSink as nC}from"@rocicorp/logger";async function*Ui(t,e){for await(let n of t)e(n)&&(yield n)}function y(t,e="Assertion failed"){if(!t)throw new Error(e)}function k(t){$t(t,"string")}function A(t){$t(t,"number")}function Mr(t){$t(t,"boolean")}function $t(t,e){typeof t!==e&&re(t,e)}function M(t){t===null&&re(t,"object"),$t(t,"object")}function ue(t){Array.isArray(t)||re(t,"array")}function _i(t,e){let n="Invalid type: ";return t==null?n+=t:n+=`${typeof t} \`${t}\``,n+`, expected ${e}`}function re(t,e){throw new Error(_i(t,e))}function vr(t){if(t===null)throw new Error("Expected non-null value")}function at(t){if(t===void 0)throw new Error("Expected non undefined value")}function so(){throw new Error("Unreachable")}var j=process.env.NODE_ENV==="production";var Ki=Object.prototype.hasOwnProperty,X=Object.hasOwn||((t,e)=>Ki.call(t,e));function W(t,e){if(t===e)return!0;if(typeof t!=typeof e)return!1;switch(typeof t){case"boolean":case"number":case"string":return!1}if(t=t,Array.isArray(t)){if(!Array.isArray(e)||t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(!W(t[r],e[r]))return!1;return!0}if(t===null||e===null||Array.isArray(e))return!1;t=t,e=e;let n=0;for(let r in t)if(X(t,r)){if(!W(t[r],e[r]))return!1;n++}let o=0;for(let r in e)X(e,r)&&o++;return n===o}function te(t){if(!j){switch(typeof t){case"boolean":case"number":case"string":return;case"object":return t===null?void 0:Array.isArray(t)?Bi(t):Hr(t)}re(t,"JSON value")}}function Nr(t){M(t),Hr(t)}function Hr(t){for(let e in t)if(X(t,e)){let n=t[e];n!==void 0&&te(n)}}function Bi(t){for(let e of t)te(e)}function Yt(t,e){switch(typeof t){case"boolean":case"number":case"string":return!0;case"object":return t===null?!0:Array.isArray(t)?Wi(t,e):qi(t,e)}return!1}function qi(t,e){for(let n in t)if(X(t,n)){e.push(n);let o=t[n];if(o!==void 0&&!Yt(o,e))return!1;e.pop()}return!0}function Wi(t,e){for(let n=0;n<t.length;n++){if(e.push(n),!Yt(t[n],e))return!1;e.pop()}return!0}async function Xt(t,e,n,o){let r={headers:{"Content-type":"application/json",Authorization:e,"X-Replicache-RequestID":n},body:JSON.stringify(o),method:"POST"},s=new Request(t,r),i=await fetch(s),a=i.status;return a!==200?[void 0,{httpStatusCode:a,errorMessage:await i.text()}]:[i,{httpStatusCode:a,errorMessage:""}]}function Vr(t,e){return t===e?0:t<e?-1:1}function Ae(t,e){if(t===e)return 0;if(t===null)return-1;if(e===null)return 1;let n=Or(t),o=Or(e);return typeof n=="string"||typeof o=="string"?Vr(String(n),String(o)):n-o}function Or(t){return typeof t=="string"||typeof t=="number"?t:t.order}function Er(t){if(!(t===null||typeof t=="string"||typeof t=="number")&&(Nr(t),!(typeof t.order=="string"||typeof t.order=="number")))throw new Error("Invalid cookie")}function Tr(t,e){return typeof t=="object"&&t!==null&&t.error===e}function io(t){return typeof t.error=="string"}function G(t){return Tr(t,"ClientStateNotFound")}function K(t){if(!Tr(t,"VersionNotSupported"))return!1;let{versionType:e}=t;switch(e){case void 0:case"pull":case"push":case"schema":return!0}return!1}function Ar(t){y(K(t))}function lt(t){M(t),A(t.httpStatusCode),k(t.errorMessage)}function ao(t){ue(t);for(let e of t)$i(e)}function $i(t){switch(M(t),t.op){case"put":k(t.key),te(t.value);break;case"del":k(t.key);break;case"clear":break;default:throw new Error(`unknown patch op \`${t.op}\`, expected one of \`put\`, \`del\`, \`clear\``)}}function lo(t){async function e(n,o){let[r,s]=await Xt(t.pullURL,t.auth,o,n);return r?{response:await r.json(),httpRequestInfo:s}:{httpRequestInfo:s}}return Fr.add(e),e}var Fr=new WeakSet;function Lr(t){return Fr.has(t)}function Yi(t){if(M(t),G(t)||K(t))return;let e=t;e.cookie!==void 0&&te(e.cookie),A(e.lastMutationID),ao(e.patch)}function Xi(t){if(M(t),G(t)||K(t))return;let e=t;e.cookie!==void 0&&Er(e.cookie),Zi(e.lastMutationIDChanges),ao(e.patch)}function Zi(t){M(t);for(let[e,n]of Object.entries(t))k(e),A(n)}function jr(t){M(t),lt(t.httpRequestInfo),t.response!==void 0&&Xi(t.response)}function zr(t){M(t),lt(t.httpRequestInfo),t.response!==void 0&&Yi(t.response)}import{resolver as ta}from"@rocicorp/resolver";var Zt=new WeakSet;function E(t){return j||co(t,[]),t}function co(t,e){switch(typeof t){case"undefined":throw new TypeError("Unexpected value undefined");case"boolean":case"number":case"string":return;case"object":{if(t===null||Zt.has(t))return;Zt.add(t),e.includes(t)&&re(t,"Cyclic JSON object"),e.push(t),Object.freeze(t),Array.isArray(t)?Qi(t,e):ea(t,e),e.pop();return}default:re(t,"JSON value")}}function Qi(t,e){for(let n of t)co(n,e)}function ea(t,e){for(let n in t)if(X(t,n)){let o=t[n];o!==void 0&&co(o,e)}}function se(t){if(!j&&!uo(t,[]))throw new Error("Expected frozen object")}function uo(t,e){switch(typeof t){case"boolean":case"number":case"string":return!0;case"object":if(t===null||Zt.has(t))return!0;if(!Object.isFrozen(t))return!1;if(e.includes(t)&&re(t,"Cyclic JSON object"),e.push(t),Array.isArray(t)){for(let n of t)if(!uo(n,e))return e.pop(),!1}else for(let n in t)if(X(t,n)){let o=t[n];if(o!==void 0&&!uo(o,e))return e.pop(),!1}return Zt.add(t),e.pop(),!0;default:re(t,"JSON value")}}function Qt(t){if(t!==void 0)return E(t)}var Jr=Promise.resolve(!0),Gr=Promise.resolve(!1),hp=Promise.resolve(void 0),U=Promise.resolve();var be=Symbol(),Fe=class{o=new Map;#e;constructor(e){this.#e=e}has(e){switch(this.o.get(e)){case void 0:return this.#e.has(e);case be:return Gr;default:return Jr}}async get(e){let n=this.o.get(e);switch(n){case be:return;case void 0:{let o=await this.#e.get(e);return Qt(o)}default:return n}}put(e,n){return this.o.set(e,E(n)),U}del(e){return this.o.set(e,be),U}release(){this.#e.release()}get closed(){return this.#e.closed}};var na={durability:"relaxed"},tn="chunks",Se=class{#e;#t=!1;#n=!1;constructor(e){this.#e=sa(e)}read(){return this.#o(ra)}write(){return this.#o(oa)}async close(){this.#n||(await this.#e).close(),this.#t=!0}get closed(){return this.#t}async#o(e){let n=async r=>{let{promise:s,resolve:i,reject:a}=ta(),l=indexedDB.open(r);l.onupgradeneeded=()=>{let c=l.transaction;vr(c),c.abort(),this.#n=!0,a(new ut(`Replicache IndexedDB not found: ${r}`))},l.onsuccess=()=>i(l.result),l.onerror=()=>a(l.error);let u=await s;return u.onversionchange=()=>u.close(),u},o=await this.#e;try{return e(o)}catch(r){if(!this.#t&&r instanceof DOMException){if(r.name==="InvalidStateError"){this.#e=n(o.name);let s=await this.#e;return e(s)}else if(r.name==="NotFoundError")throw this.#n=!0,indexedDB.deleteDatabase(o.name),new ut(`Replicache IndexedDB ${o.name} missing object store. Deleting db.`)}throw r}}},en=class{#e;#t=!1;constructor(e){this.#e=e}has(e){return new Promise((n,o)=>{let r=ho(this.#e).count(e);r.onsuccess=()=>n(r.result>0),r.onerror=()=>o(r.error)})}get(e){return new Promise((n,o)=>{let r=ho(this.#e).get(e);r.onsuccess=()=>n(Qt(r.result)),r.onerror=()=>o(r.error)})}release(){this.#t=!0}get closed(){return this.#t}},po=class extends Fe{#e;#t=!1;constructor(e){super(new en(e)),this.#e=e}commit(){return this.o.size===0?U:new Promise((e,n)=>{let o=this.#e,r=ho(o);for(let[s,i]of this.o)i===be?r.delete(s):r.put(i,s);o.oncomplete=()=>e(),o.onerror=()=>n(o.error)})}release(){this.#t=!0}get closed(){return this.#t}};function oa(t){let e=t.transaction(tn,"readwrite",na);return new po(e)}function ra(t){let e=t.transaction(tn,"readonly");return new en(e)}function ho(t){return t.objectStore(tn)}function sa(t){return new Promise((e,n)=>{let o=indexedDB.open(t);o.onupgradeneeded=()=>{o.result.createObjectStore(tn)},o.onsuccess=()=>{let r=o.result;r.onversionchange=()=>r.close(),e(r)},o.onerror=()=>n(o.error)})}var ut=class extends Error{name="IDBNotFoundError"};import{RWLock as ia}from"@rocicorp/lock";var Le=class{#e;#t;#n=!1;constructor(e,n){this.#e=e,this.#t=n}release(){this.#t(),this.#n=!0}get closed(){return this.#n}has(e){return Promise.resolve(this.#e.has(e))}get(e){return Promise.resolve(this.#e.get(e))}};var nn=class extends Fe{#e;constructor(e,n){super(new Le(e,n)),this.#e=e}commit(){return this.o.forEach((e,n)=>{e===be?this.#e.delete(n):this.#e.set(n,e)}),this.o.clear(),this.release(),U}};var Ur=new Map;var ct=class{#e;#t;#n=!1;constructor(e){let n=Ur.get(e),o,r;n?{lock:o,map:r}=n:(o=new ia,r=new Map,Ur.set(e,{lock:o,map:r})),this.#t=o,this.#e=r}async read(){let e=await this.#t.read();return new Le(this.#e,e)}async write(){let e=await this.#t.write();return new nn(this.#e,e)}close(){return this.#n=!0,U}get closed(){return this.#n}};function mo(t){return t[Symbol.asyncIterator]?.()||t[Symbol.iterator]()}async function*aa(t,e,n){let o=mo(t),r=mo(e),s=await o.next(),i=await r.next();for(;;){if(s.done){if(i.done)return;yield i.value,i=await r.next();continue}if(i.done){yield s.value,s=await o.next();continue}let a=n(s.value,i.value);a===0?(yield i.value,s=await o.next(),i=await r.next()):a<0?(yield s.value,s=await o.next()):(yield i.value,i=await r.next())}}import{LogContext as As}from"@rocicorp/logger";var Z=class extends Error{name="AbortError"};import{resolver as Gp}from"@rocicorp/resolver";var la=Promise.resolve(),_p=new Promise(()=>{});function ce(t,e){return t===0?la:new Promise((n,o)=>{let r=setTimeout(()=>{n()},t);e&&e.addEventListener("abort",()=>{clearTimeout(r),o(new Z("Aborted"))})})}function ie(t,e,n,o,r){ua(t,e,n,o,r)}async function ua(t,e,n,o,r){if(!r.aborted){for(o=o.withContext("bgIntervalProcess",t),o.debug?.("Starting");!r.aborted;){try{await ce(n(),r)}catch(s){if(!(s instanceof Z))throw s}if(!r.aborted){o.debug?.("Running");try{await e()}catch(s){r.aborted?o.debug?.("Error running most likely due to close.",s):o.error?.("Error running.",s)}}}o.debug?.("Stopping")}}var h={};Ti(h,{assert:()=>ne,is:()=>pa,parse:()=>_r,readonly:()=>da,readonlyArray:()=>pt,readonlyObject:()=>Q,readonlyRecord:()=>dt,test:()=>Do});_(h,$p);import*as je from"@badrap/valita";import*as $p from"@badrap/valita";function go(t){switch(typeof t){case"string":case"number":case"boolean":return JSON.stringify(t);case"undefined":return"undefined";case"bigint":return t.toString()+"n";default:return t===null?"null":Array.isArray(t)?"array":typeof t}}function fo(t,e){if(!e?.length)return go(t);let n=t;for(let o of e)n=n[o];return go(n)}function yo(t,e,n=o=>String(o)){if(e.length===1)return n(e[0]);let o=`${n(e[e.length-2])} ${t} ${n(e[e.length-1])}`;return e.length===2?o:`${e.slice(0,-2).map(n).join(", ")}, ${o}`}function ca(t,e){let n=t.issues[0],{path:o}=n,r=o?.length?` at ${o.join(".")}`:"";switch(n.code){case"invalid_type":return`Expected ${yo("or",n.expected)}${r}. Got ${fo(e,o)}`;case"missing_value":{let s=o&&o.length>1?` at ${o.slice(0,-1).join(".")}`:"";return n.path?.length?`Missing property ${n.path.at(-1)}${s}`:`TODO Unknown missing property${s}`}case"invalid_literal":return`Expected literal value ${yo("or",n.expected,go)}${r} Got ${fo(e,o)}`;case"invalid_length":return`Expected array with length ${n.minLength===n.maxLength?n.minLength:`between ${n.minLength} and ${n.maxLength}`}${r}. Got array with length ${e.length}`;case"unrecognized_keys":return n.keys.length===1?`Unexpected property ${n.keys[0]}${r}`:`Unexpected properties ${yo("and",n.keys)}${r}`;case"invalid_union":return`Invalid union value${r}`;case"custom_error":{let{error:s}=n;return`${s?typeof s=="string"?s:s.message??"unknown":"unknown"}${r}. Got ${fo(e,o)}`}}}function _r(t,e,n){let o=Do(t,e,n);if(!o.ok)throw new TypeError(o.error);return o.value}function pa(t,e,n){return Do(t,e,n).ok}function ne(t,e,n){_r(t,e,n)}function Do(t,e,n){let o=e.try(t,n?{mode:n}:void 0);return o.ok?o:{ok:!1,error:ca(o,t)}}function da(t){return t}function Q(t){return je.object(t)}function pt(t){return je.array(t)}function dt(t){return je.record(t)}var pe=typeof crypto<"u"&&typeof crypto.randomUUID<"u"?ma:ha;function ha(){return ya(Uint8Array.from({length:36},()=>Math.random()*256))}function ma(){return crypto.randomUUID()}var fa=[0,0,0,0,0,0,0,0,2,0,0,0,0,2,3,0,0,0,2,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0];function ya(t){return fa.map((e,n)=>{switch(e){case 0:return(t[n]&15).toString(16);case 1:return((t[n]&3)+8).toString(16);case 3:return"4";case 2:return"-"}}).join("")}var ga=/^[0-9a-v-]+$/;var Da="00000000-0000-4000-8000-000000000000",T=Da,z=Sa("",pe);function Sa(t,e){let n,o=0;return()=>{n||(n=Ia(t,e()));let r=String(o++);return Ca(n,r)}}function Ia(t,e){return t+e.replaceAll("-","").slice(t.length)}function Ca(t,e){return y(e.length<=12),t+e.padStart(12,"0")}function wa(t){return typeof t=="string"&&ga.test(t)}function B(t){ne(t,de)}var de=h.string().assert(wa,"Invalid hash");var ht=class{hash;data;meta;constructor(e,n,o){y(!o.includes(e),"Chunk cannot reference itself"),se(n),this.hash=e,this.data=n,this.meta=o}};function So(t){if(!Array.isArray(t))throw new Error("Meta must be an array");for(let e of t)k(e)}function on(t,e,n){let o=n();return new ht(o,t,e)}function Io(){throw new Error("unexpected call to compute chunk hash")}function rn(t,e,n){return new Co(t,e,n).compute()}var Co=class{#e;#t;#n;#o;#r;#s;#a;#l;constructor(e,n,o){let r=[],s=[];for(let i of e)i.old!==i.new&&(i.old&&s.push(i.old),i.new&&r.push(i.new));this.#e=r,this.#t=s,this.#n=n,this.#o=o,this.#s=new Map,this.#a=new Map,this.#l=o.areRefsCounted!==void 0,this.#r=this.#l?new Set:null}async compute(){for(let e of this.#e)await this.#c(e,1);if(await Promise.all(Array.from(this.#n.values(),e=>this.#u(e))),this.#l){y(this.#o.areRefsCounted),y(this.#r);let e;do{e=!1;for(let n of this.#n.values())if(!this.#o.areRefsCounted(n)&&!this.#r.has(n)&&this.#s.get(n)!==0){await this.#h(n,1),e=!0;break}}while(e)}for(let e of this.#t)await this.#c(e,-1);if(!j)for(let[e,n]of this.#s)y(n>=0,`ref count update must be non-negative. ${e}:${n}`);return this.#s}async#c(e,n){await this.#u(e),this.#S(e,n)&&await this.#h(e,n)}async#h(e,n){if(e===T)return;let o=await this.#o.getRefs(e);if(j||y(o||this.#l&&!this.#n.has(e),"refs must be defined"),o!==void 0){this.#r?.add(e);let r=o.map(s=>this.#c(s,n));await Promise.all(r)}}#u(e){let n=this.#a.get(e);return n===void 0&&(n=(async()=>{let o=await this.#o.getRefCount(e)||0;return this.#s.set(e,o),o})(),this.#a.set(e,n)),n}#S(e,n){let o=this.#s.get(e);return A(o),this.#s.set(e,o+n),o===0&&n===1||o===1&&n===-1}};function mt(t){return`c/${t}/d`}function ft(t){return`c/${t}/m`}function sn(t){return`c/${t}/r`}function wo(t){return`h/${t}`}var yt=class extends Error{name="ChunkNotFoundError";hash;constructor(e){super(`Chunk not found ${e}`),this.hash=e}};async function an(t,e){let n=await t.getChunk(e);if(n)return n;throw new yt(e)}async function ze(t,e){let n=await e.getHead(t);return y(n,`Missing head ${t}`),n}var Ie=class{#e;#t;#n;constructor(e,n,o){this.#e=e,this.#t=n,this.#n=o}async read(){return new ln(await this.#e.read(),this.#n)}async write(){return new xo(await this.#e.write(),this.#t,this.#n)}close(){return this.#e.close()}},ln=class{e;assertValidHash;constructor(e,n){this.e=e,this.assertValidHash=n}hasChunk(e){return this.e.has(mt(e))}async getChunk(e){let n=await this.e.get(mt(e));if(n===void 0)return;let o=await this.e.get(ft(e)),r;return o!==void 0?(So(o),r=o):r=[],new ht(e,n,r)}mustGetChunk(e){return an(this,e)}async getHead(e){let n=await this.e.get(wo(e));if(n!==void 0)return B(n),n}release(){this.e.release()}get closed(){return this.e.closed}},xo=class extends ln{#e;#t=new Set;#n=new Map;constructor(e,n,o){super(e,o),this.#e=n}createChunk=(e,n)=>on(e,n,this.#e);get kvWrite(){return this.e}async putChunk(e){let{hash:n,data:o,meta:r}=e;this.assertValidHash(n);let s=mt(n),i=this.e.put(s,o),a;if(r.length>0){for(let l of r)this.assertValidHash(l);a=this.e.put(ft(n),r)}this.#t.add(n),await i,await a}setHead(e,n){return this.#o(e,n)}removeHead(e){return this.#o(e,void 0)}async#o(e,n){let o=await this.getHead(e),r=wo(e),s;n===void 0?s=this.e.del(r):s=this.e.put(r,n);let i=this.#n.get(e);i===void 0?this.#n.set(e,{new:n,old:o}):i.new=n,await s}async commit(){let e=await rn(this.#n.values(),this.#t,this);await this.#r(e),await this.e.commit()}async getRefCount(e){let n=await this.e.get(sn(e));if(n!==void 0){if(A(n),n<0||n>65535||n!==(n|0))throw new Error(`Invalid ref count ${n}. We expect the value to be a Uint16`);return n}}async getRefs(e){let n=await this.e.get(ft(e));return n===void 0?[]:(So(n),n)}async#r(e){let n=[];for(let[o,r]of e)if(r===0)n.push(this.#s(o));else{let s=sn(o);n.push(this.e.put(s,r))}await Promise.all(n)}async#s(e){await Promise.all([this.e.del(mt(e)),this.e.del(ft(e)),this.e.del(sn(e))]),this.#t.delete(e)}release(){this.e.release()}};function bo(t){if(t!==(t|0)||t<4||t>7)throw new Error(`Unsupported format version: ${t}`);return t}var Ro=class{#e;#t;#n;constructor(e,n){this.#e=e,this.#t=n,this.#n=new Se(n)}read(){return this.#o(e=>e.read())}write(){return this.#o(e=>e.write())}async#o(e){try{return await e(this.#n)}catch(n){if(xa(n))return this.#n instanceof Se&&(this.#e.info?.("Switching to MemStore because of Firefox private browsing error"),this.#n=new ct(this.#t)),e(this.#n);throw n}}close(){return this.#n.close()}get closed(){return this.#n.closed}};function xa(t){return Kr()&&t instanceof DOMException&&t.name==="InvalidStateError"&&t.message==="A mutation operation was attempted on a database that did not allow mutations."}function Kr(){return navigator.userAgent.includes("Firefox")}function gt(t,e){return Kr()?new Ro(t,e):new Se(e)}function ko(t){return new Promise((e,n)=>{let o=indexedDB.deleteDatabase(t);o.onsuccess=()=>e(),o.onerror=()=>n(o.error)})}function H(t,e){return Po(t.read(),e)}function he(t,e){return Po(t.write(),e)}function v(t,e){return Po(t.write(),async n=>{let o=await e(n);return await n.commit(),o})}async function Po(t,e){let n=await t;try{return await e(n)}finally{n.release()}}var ba=Q({prefix:h.string().optional(),jsonPointer:h.string(),allowEmpty:h.boolean().optional()}),Br=dt(ba);function Ra(t,e){return t.jsonPointer===e.jsonPointer&&(t.allowEmpty??!1)===(e.allowEmpty??!1)&&(t.prefix??"")===(e.prefix??"")}function un(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(let[n,o]of Object.entries(t)){let r=e[n];if(!r||!Ra(o,r))return!1}return!0}var ka=Q({headHash:de,mutatorNames:pt(h.string()),indexes:Br,mutationIDs:dt(h.number()),lastServerAckdMutationIDs:h.record(h.number()),disabled:h.boolean()}),qr="client-groups";function Pa(t){ne(t,ka)}function Ma(t){M(t);let e=new Map;for(let[n,o]of Object.entries(t))o!==void 0&&(Pa(o),e.set(n,o));return e}function va(t,e){let n={};for(let[o,r]of t.entries())e.assertValidHash(r.headHash),n[o]={...r,mutatorNames:[...r.mutatorNames.values()]};return E(n)}async function Na(t,e){let n=await e.getChunk(t);return Ma(n?.data)}async function ee(t){let e=await t.getHead(qr);return e?Na(e,t):new Map}async function cn(t,e){let n=await ee(e);for(let[o,r]of t){let s=n.get(o);Wr(r,s)}return $r(t,e)}async function Dt(t,e,n){let o=await ee(n),r=o.get(t);Wr(e,r);let s=new Map(o);return s.set(t,e),$r(s,n)}function Wr(t,e){let n=new Set(t.mutatorNames);y(n.size===t.mutatorNames.length,"A client group's mutatorNames must be a set."),e!==void 0&&(y(un(e.indexes,t.indexes),"A client group's index definitions must never change."),y(Mo(n,e.mutatorNames),"A client group's mutatorNames must never change."))}async function $r(t,e){let n=va(t,e),o=Array.from(t.values(),s=>s.headHash),r=e.createChunk(n,o);return await e.putChunk(r),await e.setHead(qr,r.hash),t}function Mo(t,e){if(e.length!==t.size)return!1;for(let n of e)if(!t.has(n))return!1;return!0}async function Re(t,e){return(await ee(e)).get(t)}function pn(t){for(let[e,n]of Object.entries(t.mutationIDs)){let o=t.lastServerAckdMutationIDs[e];if(o===void 0&&n!==0||o<n)return!0}return!1}async function dn(t,e){let n=await Re(t,e);if(!n)return;let o={...n,disabled:!0};await Dt(t,o,e)}function ke(t,e){let n=t.length,o=e.length,r=Math.min(n,o);for(let s=0;s<r;){let i=t.codePointAt(s),a=e.codePointAt(s);if(i!==a){if(i<128&&a<128)return i-a;let l=Zr(i,Yr),u=Zr(a,Xr);return Ha(Yr,l,Xr,u)}s+=Va(i)}return n-o}function Ha(t,e,n,o){let r=Math.min(e,o);for(let s=0;s<r;s++){let i=t[s],a=n[s];if(i!==a)return i-a}return e-o}function Va(t){return t>65535?2:1}var Qr=()=>Array.from({length:4},()=>0),Yr=Qr(),Xr=Qr();function Zr(t,e){if(t<128)return e[0]=t,1;let n,o;if(t<=2047)n=1,o=192;else if(t<=65535)n=2,o=224;else if(t<=1114111)n=3,o=240;else throw new Error("Invalid code point");e[0]=(t>>6*n)+o;let r=1;for(;n>0;n--){let s=t>>6*(n-1);e[r++]=128|s&63}return r}function Pe(t,e){return ke(t,e)>0}function hn(t,e){return ke(t,e)<0}function mn(t,e){return ke(t,e)<=0}function fn(t,e){let n=0;for(;n<t;){let o=n+(t-n>>1),r=e(o);if(r===0)return o;r>0?n=o+1:t=o}return n}function*St(...t){for(let e of t)yield*e}var vo=0,No=1;function es(t,e,n){return E([t,n>=7?e:e.map(o=>o.slice(0,2))])}async function Ct(t,e,n,o){let r=await n.getNode(e);if(o!==n.rootHash)return Ct(t,n.rootHash,n,n.rootHash);if(Ge(r))return r;let{entries:s}=r,i=me(t,s);i===s.length&&i--;let a=s[i];return Ct(t,a[1],n,o)}function me(t,e){return fn(e.length,n=>ke(t,e[n][0]))}function wt(t,e,n){return t!==e.length&&e[t][0]===n}function Ho(t,e,n){if(j&&e>=7)return t;ue(t),se(t),y(t.length>=2);let[o,r]=t;A(o),ue(r);let s=o>0?k:te;if(e>=7){for(let a of r)Oa(a,s);return t}let i=r.map(a=>Ea(a,s,n));return[o,i]}function Oa(t,e){ue(t),y(t.length>=3),k(t[0]),e(t[1]),A(t[2])}function Ea(t,e,n){ue(t),y(t.length>=2),k(t[0]),e(t[1]);let o=n(t[0],t[1]);return[t[0],t[1],o]}var gn=class{entries;hash;isMutable;#e=-1;constructor(e,n,o){this.entries=e,this.hash=n,this.isMutable=o}maxKey(){return this.entries[this.entries.length-1][0]}getChildNodeSize(e){if(this.#e!==-1)return this.#e;let n=e.chunkHeaderSize;for(let o of this.entries)n+=o[2];return this.#e=n}c(e){this.#e=-1,e.updateNode(this)}};function Vo(t,e){return es(t.level,t.entries,e)}var Me=class extends gn{level=0;set(e,n,o,r){let s,i=me(e,this.entries);return wt(i,this.entries,e)?s=1:s=0,Promise.resolve(this.#e(r,i,s,[e,n,o]))}#e(e,n,o,...r){if(this.isMutable)return this.entries.splice(n,o,...r),this.c(e),this;let s=yn(this.entries,n,o,...r);return e.newDataNodeImpl(s)}del(e,n){let o=me(e,this.entries);return wt(o,this.entries,e)?Promise.resolve(this.#e(n,o,1)):Promise.resolve(this)}async*keys(e){for(let n of this.entries)yield n[0]}async*entriesIter(e){for(let n of this.entries)yield n}};function yn(t,e,n,...o){let r=t.slice(0,e);for(let s=0;s<o.length;s++)r.push(o[s]);for(let s=e+n;s<t.length;s++)r.push(t[s]);return r}var xt=class t extends gn{level;constructor(e,n,o,r){super(e,n,r),this.level=o}async set(e,n,o,r){let s=me(e,this.entries);s===this.entries.length&&s--;let i=this.entries[s][1],l=await(await r.getNode(i)).set(e,n,o,r),u=l.getChildNodeSize(r);if(u>r.maxSize||u<r.minSize)return this.#e(r,s,l);let c=It(l,r.getEntrySize);return this.#t(r,s,c)}async#e(e,n,o){let r=this.level-1,s=this.entries,i,a,l;if(n>0){let p=s[n-1][1],f=await e.getNode(p);i=St(f.entries,o.entries),a=n-1,l=2}else if(n<s.length-1){let p=s[n+1][1],f=await e.getNode(p);i=St(o.entries,f.entries),a=n,l=2}else i=o.entries,a=n,l=1;let u=Oo(i,p=>p[2],e.minSize-e.chunkHeaderSize,e.maxSize-e.chunkHeaderSize),c=[];for(let p of u){let f=e.newNodeImpl(p,r),g=It(f,e.getEntrySize);c.push(g)}if(this.isMutable)return this.entries.splice(a,l,...c),this.c(e),this;let d=yn(s,a,l,...c);return e.newInternalNodeImpl(d,this.level)}#t(e,n,o){if(this.isMutable)return this.entries.splice(n,1,o),this.c(e),this;let r=yn(this.entries,n,1,o);return e.newInternalNodeImpl(r,this.level)}async del(e,n){let o=me(e,this.entries);if(o===this.entries.length)return this;let r=this.entries[o][1],s=await n.getNode(r),i=s.hash,a=await s.del(e,n);if(a.hash===i)return this;if(a.entries.length===0){let l=yn(this.entries,o,1);return n.newInternalNodeImpl(l,this.level)}if(o===0&&this.entries.length===1)return a;if(a.getChildNodeSize(n)>n.minSize){let l=It(a,n.getEntrySize);return this.#t(n,o,l)}return this.#e(n,o,a)}async*keys(e){for(let n of this.entries)yield*(await e.getNode(n[1])).keys(e)}async*entriesIter(e){for(let n of this.entries)yield*(await e.getNode(n[1])).entriesIter(e)}getChildren(e,n,o){let r=[];for(let s=e;s<n&&s<this.entries.length;s++)r.push(o.getNode(this.entries[s][1]));return Promise.all(r)}async getCompositeChildren(e,n,o){let{level:r}=this;if(n===0)return new t([],z(),r-1,!0);let s=await this.getChildren(e,e+n,o);if(r>1){let a=[];for(let l of s)a.push(...l.entries);return new t(a,z(),r-1,!0)}y(r===1);let i=[];for(let a of s)i.push(...a.entries);return new Me(i,z(),!0)}};function Dn(t,e,n,o){return n===0?new Me(t,e,o):new xt(t,e,n,o)}function Ge(t){return t.level===0}function Oo(t,e,n,o){let r=[],s=[],i=0,a=[];for(let l of t){let u=e(l);u>=o?(a.length>0&&(r.push(a),s.push(i)),r.push([l]),s.push(u),i=0,a=[]):i+u>=n?(a.push(l),r.push(a),s.push(i+u),i=0,a=[]):(i+=u,a.push(l))}return i>0&&(s.length>0&&i+s[s.length-1]<=o?r[r.length-1].push(...a):r.push(a)),r}var Sn=es(0,[],7),ts=new Me([],T,!1);function It(t,e){let n=t.maxKey(),o=t.hash,r=e(n,o);return[n,o,r]}var ae=1,Ue=4,Ta=5,Aa=8;function fe(t){switch(typeof t){case"string":return ae+Ue+t.length;case"number":return Fa(t)?t<=-(2**30)||t>=2**30-1?ae+Ta:ae+Ue:ae+Aa;case"boolean":return ae;case"object":if(t===null)return ae;if(Array.isArray(t)){let e=2*ae+Ue;for(let n of t)e+=fe(n);return e}{let e=t,n=2*ae+Ue;for(let o in e)if(X(e,o)){let r=e[o];r!==void 0&&(n+=fe(o)+fe(r))}return n}}throw new Error(`Invalid value. type: ${typeof t}, value: ${t}`)}function Fa(t){return t===(t|0)}var La=2*ae+Ue+ae+Ue;function In(t,e){return La+fe(t)+fe(e)}var ns=-1,rs=0,bt=1,Rt=2,wn=3,Cn=0,os=1;function*ss(t,e){let n=0,o=0,r;function s(a,l){a[wn]===ns&&(a[wn]=l)}function i(){return[n,0,0,ns]}for(;n<t.length&&o<e.length;)t[n][Cn]===e[o][Cn]?(W(t[n][os],e[o][os])?r&&(s(r,0),yield r,r=void 0):(r||(r=i()),r[Rt]++,r[bt]++,s(r,o)),n++,o++):t[n][Cn]<e[o][Cn]?(r||(r=i()),r[bt]++,n++):(r||(r=i()),r[Rt]++,s(r,o),o++);o<e.length&&(r||(r=i()),r[Rt]+=e.length-o,s(r,o)),n<t.length&&(r||(r=i()),r[bt]+=t.length-n),r&&(s(r,0),yield r)}var ja=11,F=class{p=new Map;a;l;rootHash;getEntrySize;chunkHeaderSize;constructor(e,n,o=T,r=In,s=ja){this.a=e,this.l=n,this.rootHash=o,this.getEntrySize=r,this.chunkHeaderSize=s}async getNode(e){if(e===T)return ts;let n=this.p.get(e);if(n)return n;let o=await this.a.mustGetChunk(e),r=Ho(o.data,this.l,this.getEntrySize),s=Dn(r[No],e,r[vo],!1);return this.p.set(e,s),s}async get(e){let n=await Ct(e,this.rootHash,this,this.rootHash),o=me(e,n.entries);if(wt(o,n.entries,e))return n.entries[o][1]}async has(e){let n=await Ct(e,this.rootHash,this,this.rootHash),o=me(e,n.entries);return wt(o,n.entries,e)}async isEmpty(){let{rootHash:e}=this,n=await this.getNode(this.rootHash);return this.rootHash!==e?this.isEmpty():n.entries.length===0}scan(e){return Eo(this.rootHash,()=>this.rootHash,this.rootHash,e,async n=>{let o=await this.getNode(n);if(o)return[o.level,o.isMutable?o.entries.slice():o.entries];let r=await this.a.mustGetChunk(n);return Ho(r.data,this.l,this.getEntrySize)})}async*keys(){yield*(await this.getNode(this.rootHash)).keys(this)}async*entries(){yield*(await this.getNode(this.rootHash)).entriesIter(this)}[Symbol.asyncIterator](){return this.entries()}async*diff(e){let[n,o]=await Promise.all([this.getNode(this.rootHash),e.getNode(e.rootHash)]);yield*xn(o,n,e,this)}};async function*xn(t,e,n,o){if(t.level>e.level){let s=await t.getCompositeChildren(0,t.entries.length,n);yield*xn(s,e,n,o);return}if(e.level>t.level){let s=await e.getCompositeChildren(0,e.entries.length,o);yield*xn(t,s,n,o);return}if(Ge(t)&&Ge(e)){yield*za(t.entries,e.entries);return}let r=ss(t.entries,e.entries);for(let s of r){let[i,a]=await Promise.all([t.getCompositeChildren(s[rs],s[bt],n),e.getCompositeChildren(s[wn],s[Rt],o)]);yield*xn(i,a,n,o)}}function*za(t,e){let n=t.length,o=e.length,r=0,s=0;for(;r<n&&s<o;){let i=t[r][0],a=e[s][0];i===a?(W(t[r][1],e[s][1])||(yield{op:"change",key:i,oldValue:t[r][1],newValue:e[s][1]}),r++,s++):i<a?(yield{op:"del",key:i,oldValue:t[r][1]},r++):(yield{op:"add",key:a,newValue:e[s][1]},s++)}for(;r<n;r++)yield{op:"del",key:t[r][0],oldValue:t[r][1]};for(;s<o;s++)yield{op:"add",key:e[s][0],newValue:e[s][1]}}async function*Eo(t,e,n,o,r){if(n===T)return;let s=await r(n),i=s[No],a=0;if(o&&(a=me(o,i)),s[vo]>0)for(;a<i.length;a++)yield*Eo(t,e,i[a][1],o,r),o="";else for(;a<i.length;a++){let l=e();if(t!==l){yield*Eo(l,e,l,i[a][0],r);return}yield i[a]}}async function _e(t,e){let n=[],o=e==="add"?r=>({op:"add",key:r[0],newValue:r[1]}):r=>({op:"del",key:r[0],oldValue:r[1]});for await(let r of t.entries())n.push(o(r));return n}var N="main";function To(t){return Ka(t.meta)}function ve(t){return Be(t.meta)}function Ja(t){return ve(t)||To(t)}function Ga(t){return us(t.meta)}function Ua(t){return Wa(t.meta)}function Ao(t){return Ga(t)||Ua(t)}var bn=class{chunk;constructor(e){this.chunk=e}get meta(){return this.chunk.data.meta}get valueHash(){return this.chunk.data.valueHash}getMutationID(e,n){return Rn(e,n,this.meta)}async getNextMutationID(e,n){return await this.getMutationID(e,n)+1}get indexes(){return this.chunk.data.indexes}};async function Rn(t,e,n){switch(n.type){case 1:return n.lastMutationID;case 3:return n.lastMutationID;case 5:return n.lastMutationIDs[t]??0;case 2:return n.mutationID;case 4:{if(n.clientID===t)return n.mutationID;let{basisHash:o}=n,r=await O(o,e);return Rn(t,e,r.meta)}default:so()}}async function kn(t,e){return(await Nn(t,e)).filter(o=>Ja(o))}async function Pn(t,e){return(await Nn(t,e)).filter(o=>ve(o))}async function Mn(t,e,n){let o=[],r=new Map(Object.entries(e));for(;!Ao(t)&&r.size>0;){if(ve(t)){let{meta:i}=t,a=r.get(i.clientID);a!==void 0&&(i.mutationID<=a?r.delete(i.clientID):o.push(t))}let{basisHash:s}=t.meta;if(s===null)throw new Error(`Commit ${t.chunk.hash} has no basis`);t=await O(s,n)}return o}async function is(t,e){let n=await e.getHead(t);return y(n,`Missing head ${t}`),$(n,e)}async function Fo(t,e){return(await $(t,e)).chunk.hash}async function $(t,e){let n=await O(t,e);return Ne(n,e)}async function Ne(t,e){for(;!Ao(t);){let{meta:n}=t;if(Be(n))t=await O(n.baseSnapshotHash,e);else{let{basisHash:o}=n;if(o===null)throw new Error(`Commit ${t.chunk.hash} has no basis`);t=await O(o,e)}}return t}function vn(t,e){let n=t.meta;return us(n)?[n.lastMutationIDs[e]??0,n.cookieJSON]:[n.lastMutationID,n.cookieJSON]}function kt(t,e){return Ae(t.meta.cookieJSON,e.meta.cookieJSON)}async function Nn(t,e){let n=await O(t,e),o=[];for(;!Ao(n);){let{meta:r}=n,{basisHash:s}=r;if(s===null)throw new Error(`Commit ${n.chunk.hash} has no basis`);o.push(n),n=await O(s,e)}return o.push(n),o}async function O(t,e){let n=await e.mustGetChunk(t);return el(n)}async function Ke(t,e){let n=await ze(t,e);return O(n,e)}function _a(t){A(t.lastMutationID)}function as(t){if(A(t.mutationID),k(t.mutatorName),!t.mutatorName)throw new Error("Missing mutator name");te(t.mutatorArgsJSON),t.originalHash!==null&&B(t.originalHash),A(t.timestamp)}function Lo(t){k(t.clientID),as(t)}function Be(t){return t.type===4}function Ka(t){return t.type===2}function ls(t){t.basisHash!==null&&B(t.basisHash),te(t.cookieJSON)}function Ba(t){ls(t),A(t.lastMutationID)}function Pt(t){ls(t),qa(t.lastMutationIDs)}function qa(t){M(t);for(let e of Object.values(t))A(e)}function le(t){Pt(t.meta)}function us(t){return t.type===5}function Wa(t){return t.type===3}function $a(t){switch(M(t),se(t),t.basisHash!==null&&k(t.basisHash),A(t.type),t.type){case 1:_a(t);break;case 2:as(t);break;case 4:Lo(t);break;case 3:Ba(t);break;case 5:Pt(t);break;default:throw new Error(`Invalid enum value ${t.type}`)}}function cs(t,e){return t.jsonPointer===e.jsonPointer&&(t.allowEmpty??!1)===(e.allowEmpty??!1)&&t.keyPrefix===e.keyPrefix}function Ya(t){M(t),se(t),k(t.name),k(t.keyPrefix),k(t.jsonPointer),t.allowEmpty!==void 0&&Mr(t.allowEmpty)}function ps(t,e){return{name:t,keyPrefix:e.prefix??"",jsonPointer:e.jsonPointer,allowEmpty:e.allowEmpty??!1}}function Xa(t){M(t),se(t),Ya(t.definition),k(t.valueHash)}function Za(t){ue(t),se(t);for(let e of t)Xa(e)}function ds(t,e,n,o,r,s,i,a,l){return Mt(t,vt({type:2,basisHash:e,mutationID:n,mutatorName:o,mutatorArgsJSON:r,originalHash:s,timestamp:l},i,a))}function hs(t,e,n,o,r,s,i,a,l,u,c){return Mt(t,vt({type:4,basisHash:e,baseSnapshotHash:n,mutationID:o,mutatorName:r,mutatorArgsJSON:s,originalHash:i,timestamp:u,clientID:c},a,l))}function ms(t,e,n,o,r,s){return Mt(t,Qa(e,n,o,r,s))}function fs(t,e,n,o,r,s){return Mt(t,jo(e,n,o,r,s))}function Qa(t,e,n,o,r){return vt({type:3,basisHash:t,lastMutationID:e,cookieJSON:n},o,r)}function jo(t,e,n,o,r){return vt({type:5,basisHash:t,lastMutationIDs:e,cookieJSON:n},o,r)}function ys(t,e,n,o,r){return Mt(t,vt({type:1,basisHash:e,lastMutationID:n},o,r))}function el(t){return nl(t),new bn(t)}function Mt(t,e){return new bn(t(e,zo(e)))}function zo(t){let e=[t.valueHash],{meta:n}=t;switch(n.type){case 1:n.basisHash&&e.push(n.basisHash);break;case 2:case 4:n.basisHash&&e.push(n.basisHash);break;case 3:case 5:break;default:so()}for(let o of t.indexes)e.push(o.valueHash);return e}function vt(t,e,n){return E({meta:t,valueHash:e,indexes:n})}function tl(t){j||(M(t),se(t),$a(t.meta),k(t.valueHash),Za(t.indexes))}function nl(t){let{data:e}=t;tl(e);let n=new Set;for(let o of e.indexes){let{name:r}=o.definition;if(n.has(r))throw new Error(`Duplicate index ${r}`);n.add(r)}}async function Hn(t){let e=[];for await(let n of t)e.push(n);return e}function Ce(t,e){return Hn(e.diff(t))}import{Lock as ol}from"@rocicorp/lock";var we=class extends F{#e=new ol;#t=new Map;minSize;maxSize;constructor(e,n,o=T,r=8*1024,s=16*1024,i=In,a){super(e,n,o,i,a),this.minSize=r,this.maxSize=s}#n(e){y(e.isMutable),this.#t.set(e.hash,e),this.p.set(e.hash,e)}updateNode(e){y(e.isMutable),this.#t.delete(e.hash),e.hash=z(),this.#n(e)}newInternalNodeImpl(e,n){let o=new xt(e,z(),n,!0);return this.#n(o),o}newDataNodeImpl(e){let n=new Me(e,z(),!0);return this.#n(n),n}newNodeImpl(e,n){let o=Dn(e,z(),n,!0);return this.#n(o),o}put(e,n){return this.#e.withLock(async()=>{let o=await this.getNode(this.rootHash),r=this.getEntrySize(e,n),s=await o.set(e,n,r,this);if(s.getChildNodeSize(this)>this.maxSize){let i=this.chunkHeaderSize,a=Oo(s.entries,d=>d[2],this.minSize-i,this.maxSize-i),{level:l}=s,u=a.map(d=>{let p=this.newNodeImpl(d,l);return It(p,this.getEntrySize)}),c=this.newInternalNodeImpl(u,l+1);this.rootHash=c.hash;return}this.rootHash=s.hash})}del(e){return this.#e.withLock(async()=>{let o=await(await this.getNode(this.rootHash)).del(e,this),r=this.rootHash!==o.hash;return r&&(o.level>0&&o.entries.length===1?this.rootHash=o.entries[0][1]:this.rootHash=o.hash),r})}clear(){return this.#e.withLock(()=>{this.#t.clear(),this.rootHash=T})}flush(){return this.#e.withLock(async()=>{let e=this.a;if(this.rootHash===T){let r=e.createChunk(Sn,[]);return await e.putChunk(r),r.hash}let n=[],o=gs(this.rootHash,n,e.createChunk,this.#t,this.l);return await Promise.all(n.map(r=>e.putChunk(r))),this.#t.clear(),this.rootHash=o,o})}};function gs(t,e,n,o,r){let s=o.get(t);if(s===void 0)return t;if(Ge(s)){let u=n(Vo(s,r),[]);return e.push(u),u.hash}let i=[],{entries:a}=s;for(let u=0;u<a.length;u++){let c=a[u],d=c[1],p=gs(d,e,n,o,r);p!==d&&(a[u]=[c[0],p,c[2]]),i.push(p)}let l=n(Vo(s,r),i);return e.push(l),l.hash}function Jo(t){let e;return()=>(e===void 0&&(e=t()),e)}var Nt=class{meta;map;constructor(e,n){this.meta=e,this.map=n}},Vn=class extends Nt{flush(){return this.map.flush()}clear(){return this.map.clear()}};async function On(t,e,n,o,r,s,i){try{for(let a of rl(o,r,s,i))switch(n){case 0:await e.put(a,r);break;case 1:await e.del(a);break}}catch(a){t.info?.("Not indexing value",r,":",a)}}function rl(t,e,n,o){let r=sl(e,n);if(r===void 0){if(o)return[];throw new Error(`No value at path: ${n}`)}let s=Array.isArray(r)?r:[r],i=[];for(let a of s)if(typeof a=="string")i.push(Ds([a,t]));else throw new Error("Unsupported target type");return i}var Go="\0",Uo="\0";function Ds(t){let e=t[0],n=t[1];if(e.includes("\0"))throw new Error("Secondary key cannot contain null byte");return Go+e+Uo+n}function _o(t,e){let n=Ds([t,e||""]);return e===void 0?n.slice(0,n.length-1):n}function qe(t){if(t[0]!==Go)throw new Error("Invalid version");let e=Go.length,n=Uo.length,o=t.indexOf(Uo,e);if(o===-1)throw new Error("Invalid formatting");let r=t.slice(e,o),s=t.slice(o+n);return[r,s]}function sl(t,e){function n(s){if(!(s.startsWith("+")||s.startsWith("0")&&s.length!==1))return parseInt(s,10)}if(e==="")return t;if(!e.startsWith("/"))throw new Error(`Invalid JSON pointer: ${e}`);let o=e.split("/").slice(1).map(s=>s.replace(/~1/g,"/").replace(/~0/g,"~")),r=t;for(let s of o){let i;if(Array.isArray(r)){let a=n(s);if(a===void 0)return;i=r[a]}else{if(r===null)return;typeof r=="object"&&(r=r,i=r[s])}if(i===void 0)return;r=i}return r}var Ht=class{#e;map;indexes;constructor(e,n,o){this.#e=e,this.map=n,this.indexes=o}has(e){return this.map.has(e)}get(e){return this.map.get(e)}isEmpty(){return this.map.isEmpty()}getMapForIndex(e){let n=this.indexes.get(e);if(n===void 0)throw new Error(`Unknown index name: ${e}`);return n.map}get closed(){return this.#e.closed}close(){this.#e.release()}};function Ss(t,e){return il(N,t,e)}async function il(t,e,n){let o=await Ke(t,e);return al(o,e,n)}function al(t,e,n){let o=We(t,e,n),r=new F(e,n,t.valueHash);return new Ht(e,r,o)}function We(t,e,n){let o=new Map;for(let r of t.indexes)o.set(r.definition.name,new Nt(r,new F(e,n,r.valueHash)));return o}var He=class extends Map{set(e,n){return n.length===0?this:super.set(e,n)}};async function Is(t,e,n,o,r){let s=new He;if(!o.shouldComputeDiffs())return s;let i=new F(n,r,t.valueHash),a=new F(n,r,e.valueHash),l=await Ce(i,a);return s.set("",l),await Ko(t,e,n,s,o,r),s}async function Ko(t,e,n,o,r,s){let i=We(t,n,s),a=We(e,n,s);for(let[l,u]of i){if(!r.shouldComputeDiffsForIndex(l))continue;let c=a.get(l);if(c!==void 0){y(c!==u);let d=await Ce(u.map,c.map);a.delete(l),o.set(l,d)}else{let d=await _e(u.map,"del");o.set(l,d)}}for(let[l,u]of a){if(!r.shouldComputeDiffsForIndex(l))continue;let c=await _e(u.map,"add");o.set(l,c)}}var Vt=class extends Ht{#e;#t;#n;#o;#r;constructor(e,n,o,r,s,i,a){super(e,n,s),this.#e=e,this.#t=o,this.#n=r,this.#o=i,this.#r=a,o===void 0?y(r.basisHash===T):y(r.basisHash===o.chunk.hash)}async put(e,n,o){if(this.#n.type===1)throw new Error("Not allowed");let r=Jo(()=>this.map.get(n));await En(e,this.indexes,n,r,o),await this.map.put(n,o)}getMutationID(){return Rn(this.#o,this.#e,this.#n)}async del(e,n){if(this.#n.type===1)throw new Error("Not allowed");let o=Jo(()=>this.map.get(n));return o!==void 0&&await En(e,this.indexes,n,o,void 0),this.map.del(n)}async clear(){if(this.#n.type===1)throw new Error("Not allowed");await this.map.clear();let e=[];for(let n of this.indexes.values())e.push(n.clear());await Promise.all(e)}async putCommit(){let e=await this.map.flush(),n=[];for(let s of this.indexes.values()){let i=await s.flush(),a={definition:s.meta.definition,valueHash:i};n.push(a)}let o,r=this.#n;switch(r.type){case 2:{let{basisHash:s,mutationID:i,mutatorName:a,mutatorArgsJSON:l,originalHash:u,timestamp:c}=r;o=ds(this.#e.createChunk,s,i,a,l,u,e,n,c);break}case 4:{y(this.#r>=5);let{basisHash:s,mutationID:i,mutatorName:a,mutatorArgsJSON:l,originalHash:u,timestamp:c}=r;o=hs(this.#e.createChunk,s,await Fo(s,this.#e),i,a,l,u,e,n,c,this.#o);break}case 3:{y(this.#r<=4);let{basisHash:s,lastMutationID:i,cookieJSON:a}=r;o=ms(this.#e.createChunk,s,i,a,e,n);break}case 5:{y(this.#r>5);let{basisHash:s,lastMutationIDs:i,cookieJSON:a}=r;o=fs(this.#e.createChunk,s,i,a,e,n);break}case 1:{let{basisHash:s,lastMutationID:i}=r;if(this.#t!==void 0){if(await this.#t.getMutationID(this.#o,this.#e)!==i)throw new Error("Index change must not change mutationID");if(this.#t.valueHash!==e)throw new Error("Index change must not change valueHash")}o=ys(this.#e.createChunk,s,i,e,n);break}}return await this.#e.putChunk(o.chunk),o}async commit(e){let o=(await this.putCommit()).chunk.hash;return await this.#e.setHead(e,o),await this.#e.commit(),o}async commitWithDiffs(e,n){let o=this.putCommit(),r=await this.#s(n),s=(await o).chunk.hash;return await this.#e.setHead(e,s),await this.#e.commit(),[s,r]}async#s(e){let n=new He;if(!e.shouldComputeDiffs())return n;let o=[];if(this.#t){let s=new F(this.#e,this.#r,this.#t.valueHash);o=await Ce(s,this.map)}n.set("",o);let r;this.#t?r=We(this.#t,this.#e,this.#r):r=new Map;for(let[s,i]of this.indexes){if(!e.shouldComputeDiffsForIndex(s))continue;let a=r.get(s);y(i!==a);let l=await(a?Ce(a.map,i.map):_e(i.map,"add"));n.set(s,l)}for(let[s,i]of r)if(!this.indexes.has(s)&&e.shouldComputeDiffsForIndex(s)){let a=await _e(i.map,"del");n.set(s,a)}return n}close(){this.#e.release()}};async function Tn(t,e,n,o,r,s,i,a){let l=await O(t,r),u=new we(r,a,l.valueHash),c=await l.getNextMutationID(i,r),d=An(l,r,a);return new Vt(r,u,l,a>=5?{type:4,basisHash:t,baseSnapshotHash:await Fo(t,r),mutatorName:e,mutatorArgsJSON:n,mutationID:c,originalHash:o,timestamp:s,clientID:i}:{type:2,basisHash:t,mutatorName:e,mutatorArgsJSON:n,mutationID:c,originalHash:o,timestamp:s},d,i,a)}async function Cs(t,e,n,o,r,s,i){y(i<=4);let a=await O(t,o),l=new we(o,i,a.valueHash);return new Vt(o,l,a,{basisHash:t,type:3,lastMutationID:e,cookieJSON:n},r,s,i)}async function ws(t,e,n,o,r,s){let i=await O(t,o),a=new we(o,s,i.valueHash);return new Vt(o,a,i,{basisHash:t,type:5,lastMutationIDs:e,cookieJSON:n},An(i,o,s),r,s)}async function En(t,e,n,o,r){let s=[];for(let i of e.values()){let{keyPrefix:a}=i.meta.definition;if(!a||n.startsWith(a)){let l=await o();l!==void 0&&s.push(On(t,i.map,1,n,l,i.meta.definition.jsonPointer,i.meta.definition.allowEmpty??!1)),r!==void 0&&s.push(On(t,i.map,0,n,r,i.meta.definition.jsonPointer,i.meta.definition.allowEmpty??!1))}}await Promise.all(s)}function An(t,e,n){let o=new Map;for(let r of t.indexes)o.set(r.definition.name,new Vn(r,new we(e,n,r.valueHash)));return o}async function xs(t,e,n,o,r,s,i){let a=new we(e,i);for await(let l of n.scan(o)){let u=l[0];if(!u.startsWith(o))break;await On(t,a,0,u,l[1],r,s)}return a}var Ot=h.string(),Bo=h.string();var bs=Q({heartbeatTimestampMs:h.number(),headHash:de,mutationID:h.number(),lastServerAckdMutationID:h.number()}),ll=Q({heartbeatTimestampMs:h.number(),headHash:de,tempRefreshHash:de.nullable(),clientGroupID:Ot}),Rs=Q({heartbeatTimestampMs:h.number(),refreshHashes:pt(de),persistHash:de.nullable(),clientGroupID:Ot});function ks(t){return t.refreshHashes!==void 0}function qo(t){return t.clientGroupID!==void 0}var Ps="clients",ul=h.union(bs,ll,Rs);function cl(t){ne(t,ul)}function Wo(t){ne(t,bs)}function $e(t){ne(t,Rs)}function pl(t){M(t);let e=new Map;for(let n in t)if(X(t,n)){let o=t[n];o!==void 0&&(cl(o),e.set(n,o))}return e}function dl(t,e){for(let n of t.values())ks(n)?(n.refreshHashes.forEach(e.assertValidHash),n.persistHash&&e.assertValidHash(n.persistHash)):(e.assertValidHash(n.headHash),qo(n)&&n.tempRefreshHash&&e.assertValidHash(n.tempRefreshHash));return E(Object.fromEntries(t))}async function q(t){let e=await t.getHead(Ps);return hl(e,t)}async function hl(t,e){if(!t)return new Map;let n=await e.getChunk(t);return pl(n?.data)}var Y=class extends Error{name="ClientStateNotFoundError";id;constructor(e){super(`Client state not found, id: ${e}`),this.id=e}};async function Ms(t,e){if(!await $o(t,e))throw new Y(t)}async function $o(t,e){return!!await Yo(t,e)}async function Yo(t,e){return(await q(e)).get(t)}async function Et(t,e){let n=await Yo(t,e);if(!n)throw new Y(t);return n}function vs(t,e,n,o,r,s){return he(n,async i=>{async function a(m,S,D,I){let C=jo(m,{},S,D,I),w=i.createChunk(C,zo(C)),P=pe(),x={heartbeatTimestampMs:Date.now(),refreshHashes:[w.hash],persistHash:null,clientGroupID:P},V=new Map(l).set(t,x),R={headHash:w.hash,mutatorNames:o,indexes:r,mutationIDs:{},lastServerAckdMutationIDs:{},disabled:!1};return await Promise.all([i.putChunk(w),ye(V,i),Dt(P,R,i)]),await i.commit(),[x,w.hash,V,!0]}let l=await q(i),u=await fl(i,o,r);if(u.type===Vs){let{clientGroupID:m,headHash:S}=u,D={clientGroupID:m,refreshHashes:[S],heartbeatTimestampMs:Date.now(),persistHash:null},I=new Map(l).set(t,D);return await ye(I,i),await i.commit(),[D,S,I,!1]}if(u.type===Ns){let m=i.createChunk(Sn,[]);await i.putChunk(m);let S=[];for(let[D,I]of Object.entries(r)){let C=ps(D,I);S.push({definition:C,valueHash:m.hash})}return a(null,null,m.hash,S)}y(u.type===Hs);let{snapshot:c}=u,d=[],{valueHash:p,indexes:f}=c,g=new F(i,s,p);for(let[m,S]of Object.entries(r)){let{prefix:D="",jsonPointer:I,allowEmpty:C=!1}=S,w={name:m,keyPrefix:D,jsonPointer:I,allowEmpty:C},P=ml(f,w);if(P)d.push({definition:w,valueHash:P.valueHash});else{let x=await xs(e,i,g,D,I,C,s);d.push({definition:w,valueHash:await x.flush()})}}return a(c.meta.basisHash,c.meta.cookieJSON,c.valueHash,d)})}function ml(t,e){return t.find(n=>cs(n.definition,e))}var Ns=0,Hs=1,Vs=2;async function fl(t,e,n){let o,r,s=new Set(e),i=await ee(t);for(let[a,l]of i){if(!l.disabled&&Mo(s,l.mutatorNames)&&un(n,l.indexes))return{type:Vs,clientGroupID:a,headHash:l.headHash};let u=await $(l.headHash,t);le(u);let{cookieJSON:c}=u.meta;(o===void 0||Ae(c,o)>0)&&(o=c,r=u)}return r?{type:Hs,snapshot:r}:{type:Ns}}function yl(t){let e=[];for(let n of t.values())ks(n)?(e.push(...n.refreshHashes),n.persistHash&&e.push(n.persistHash)):(e.push(n.headHash),qo(n)&&n.tempRefreshHash&&e.push(n.tempRefreshHash));return e}async function Os(t,e){let n=await Xo(t,e);if(n)return Re(n,e)}async function Xo(t,e){let n=await Yo(t,e);if(!(!n||!qo(n)))return n.clientGroupID}async function Tt(t,e,n){let o=await q(n),r=new Map(o).set(t,e);return ye(r,n)}async function ye(t,e){let n=dl(t,e),o=e.createChunk(n,yl(t));return await e.putChunk(o),await e.setHead(Ps,o.hash),o.hash}var gl=0,Dl="replicache-dbs-v"+gl,Sl="";function Es(){return Sl+Dl}var Fn="dbs",Ts="profileId";function Il(t){M(t);for(let[e,n]of Object.entries(t))k(e),Cl(n),y(e===n.name)}function Cl(t){M(t),k(t.name),k(t.replicacheName),A(t.replicacheFormatVersion),k(t.schemaVersion),t.lastOpenedTimestampMS!==void 0&&A(t.lastOpenedTimestampMS)}var Ve=class{#e;constructor(e){this.#e=e(Es())}putDatabase(e){return this.#t({...e,lastOpenedTimestampMS:Date.now()})}putDatabaseForTesting(e){return this.#t(e)}#t(e){return v(this.#e,async n=>{let r={...await Zo(n),[e.name]:e};return await n.put(Fn,r),r})}clearDatabases(){return v(this.#e,e=>e.del(Fn))}deleteDatabases(e){return v(this.#e,async n=>{let r={...await Zo(n)};for(let s of e)delete r[s];await n.put(Fn,r)})}getDatabases(){return H(this.#e,Zo)}close(){return this.#e.close()}getProfileID(){return v(this.#e,async e=>{let n=await e.get(Ts);return n===void 0&&(n=`p${pe().replace(/-/g,"")}`,await e.put(Ts,n)),k(n),n})}};async function Zo(t){let e=await t.get(Fn);return e||(e=E({})),Il(e),e}var wl=12*60*60*1e3,xl=30*24*60*60*1e3,bl=14*24*60*60*1e3,Rl=5*60*1e3;function Fs(t,e,n){let o=!0;ie("CollectIDBDatabases",async()=>{await kl(t,Date.now(),xl,bl)},()=>o?(o=!1,Rl):wl,e,n)}async function kl(t,e,n,o,r=Pl){let s=await t.getDatabases(),i=Object.values(s),l=(await Promise.all(i.map(async c=>[c.name,await Ml(c,e,n,o,r)]))).filter(c=>c[1]).map(c=>c[0]),{errors:u}=await js(t,l);if(u.length)throw u[0]}async function Ls(t,e){await ko(t),await e.deleteDatabases([t])}async function js(t,e){let n=await Promise.allSettled(e.map(async s=>(await Ls(s,t),s))),o=[],r=[];for(let s of n)s.status==="fulfilled"?o.push(s.value):r.push(s.reason);return{dropped:o,errors:r}}function Pl(t){let e=new Se(t);return new Ie(e,z,B)}async function Ml(t,e,n,o,r){if(t.replicacheFormatVersion>7)return!1;if(t.lastOpenedTimestampMS!==void 0){let a=t.replicacheFormatVersion>=5;return e-t.lastOpenedTimestampMS<(a?o:n)?!1:a?(y(t.replicacheFormatVersion===5||t.replicacheFormatVersion===6||t.replicacheFormatVersion===7),!await Vl(r(t.name))):!0}let s=r(t.name),i=await H(s,q);return await s.close(),vl(i,e,n)}function vl(t,e,n){for(let o of t.values())if(e-o.heartbeatTimestampMs<n)return!1;return!0}async function Nl(t,e=n=>gt(new As,n)){await Ls(t,new Ve(e))}async function zs(t=e=>gt(new As,e)){let e=new Ve(t),n=await e.getDatabases(),o=Object.values(n).map(s=>s.name);return await js(e,o)}function Hl(t){return zs(t)}async function Vl(t){let e=await H(t,ee);for(let n of e.values())if(pn(n))return!0;return!1}import{consoleLogSink as Au,LogContext as Fu,TeeLogSink as Lu}from"@rocicorp/logger";import{resolver as nt}from"@rocicorp/resolver";import{resolver as Ol}from"@rocicorp/resolver";function Js(t,e,n){return t?new Qo(t,e,n):new er}var Qo=class{#e;#t;#n=0;visibilityState;#o=new Set;constructor(e,n,o){this.#e=e,this.#t=n,this.visibilityState=e.visibilityState,this.#e.addEventListener("visibilitychange",this.#r,{signal:o})}#r=()=>{this.#e.visibilityState==="visible"?(clearTimeout(this.#n),this.#s("visible")):this.#n=setTimeout(()=>{this.#s("hidden")},this.#t)};#s(e){if(e!==this.visibilityState){this.visibilityState=e;for(let n of this.#o){let{resolve:o,state:r}=n;r===e&&(o(),this.#o.delete(n))}}}waitForVisible(){return this.#a("visible")}waitForHidden(){return this.#a("hidden")}#a(e){if(this.visibilityState===e)return Promise.resolve();let{promise:n,resolve:o}=Ol();return this.#o.add({resolve:o,state:e}),n}},El=Promise.resolve(),Tl=new Promise(()=>{}),er=class{visibilityState="visible";waitForVisible(){return El}waitForHidden(){return Tl}};function At(){return typeof document<"u"?document:void 0}var Ln=class{rep;invokeSend;maxConnections=1;constructor(e,n){this.rep=e,this.invokeSend=n}get maxDelayMs(){return this.rep.requestOptions.maxDelayMs}get minDelayMs(){return this.rep.requestOptions.minDelayMs}},jn=class extends Ln{debounceDelay=0;get watchdogTimer(){return this.rep.pullInterval}},zn=class extends Ln{get debounceDelay(){return this.rep.pushDelay}watchdogTimer=null};import{resolver as ge}from"@rocicorp/resolver";var Us=30,_s=6e4,Ft=class{#e=ge();#t=ge();#n=ge();#o;#r=!1;#s=0;#a;#l;constructor(e,n,o){this.#a=e,this.#o=n,this.#l=o,this.run()}close(){this.#r=!0,this.#s>0&&this.#n.resolve({error:Gs()})}async send(e){if(this.#r)return{error:Gs()};this.#s++,this.#a.debug?.("send",e),e?this.#t.resolve():await this.#l?.waitForVisible(),this.#e.resolve();let n=await this.#n.promise;return this.#s--,n}async run(){let e=[],n=ge(),o,r=0,s=this.#o,{debug:i}=this.#a,a=0;i?.("Starting connection loop");let l=u=>Promise.race([this.#t.promise,ce(u)]);for(;!this.#r;){i?.(tr(e)?"Last request failed. Trying again":"Waiting for a send");let u=[this.#e.promise],c=s.watchdogTimer;if(c!==null&&u.push(ce(c)),await Promise.race(u),this.#r||(i?.("Waiting for debounce"),await l(s.debounceDelay),this.#r))break;if(i?.("debounced"),this.#e=ge(),r>=s.maxConnections){if(i?.("Too many request in flight. Waiting until one finishes..."),await this.#u(),this.#r)break;i?.("...finished")}r>0||tr(e)?(a=Fl(a,s,e),i?.(tr(e)?"Last connection errored. Sleeping for":"More than one outstanding connection ("+r+"). Sleeping for",a,"ms")):a=0;let d=Math.min(s.maxDelayMs,Math.max(s.minDelayMs,a));if(o!==void 0){let p=Date.now()-o;if(d>p&&(await Promise.race([l(d-p),n.promise]),this.#r))break}r++,(async()=>{let p=Date.now(),f,g;try{o=p,i?.("Sending request"),this.#t=ge(),f=await s.invokeSend(),i?.("Send returned",f)}catch(S){i?.("Send failed",S),g=S,f=!1}if(this.#r){i?.("Closed after invokeSend");return}i?.("Request done",{duration:Date.now()-p,ok:f}),e.push({duration:Date.now()-p,ok:f}),jl(e)&&(n.resolve(),n=ge()),r--,this.#h();let m=this.#n;this.#n=ge(),g?m.resolve({error:g}):m.resolve(void 0),f||this.#e.resolve()})()}}#c=void 0;#h(){if(this.#c){let e=this.#c;this.#c=void 0,e()}}#u(){let{promise:e,resolve:n}=ge();return this.#c=n,e}},Al=9;function Gs(){return new Error("Closed")}function Fl(t,e,n){let{length:o}=n;if(o===0)return t;let{ok:r}=n[n.length-1],{maxConnections:s,minDelayMs:i}=e;if(!r)return t===0?i:t*2;if(o>1){let l=n[n.length-2];for(;n.length>Al;)n.shift();if(r&&!l.ok)return i}return Ll(n.filter(({ok:l})=>l).map(({duration:l})=>l))/s|0}function Ll(t){t.sort();let{length:e}=t,n=e>>1;return e%2===1?t[n]:(t[n-1]+t[n])/2}function tr(t){return t.length>0&&!t[t.length-1].ok}function jl(t){return t.length>1&&!t[t.length-2].ok&&t[t.length-1].ok}import{RWLock as zl}from"@rocicorp/lock";var Oe=class{#e=new zl;#t=new Map;#n;#o;#r;t=new Map;n;h=new Map;m=new Map;constructor(e,n,o,r,s=fe){this.n=new or(n,s,this.h,this.m),this.#n=e,this.#o=o,this.#r=r}async read(){let e=await this.#e.read();return new Jn(this.#t,this.t,this.n,this.#n,e,this.#r)}async write(){let e=await this.#e.write();return new nr(this.#t,this.t,this.n,this.#n,this.h,this.m,e,this.#o,this.#r)}close(){return U}isCached(e){return this.n.getWithoutUpdatingLRU(e)!==void 0}withSuspendedSourceCacheEvictsAndDeletes(e){return this.n.withSuspendedEvictsAndDeletes(e)}},Jn=class{u;t;n;f;#e=void 0;#t;#n=!1;assertValidHash;constructor(e,n,o,r,s,i){this.u=e,this.t=n,this.n=o,this.f=r,this.#t=s,this.assertValidHash=i}isMemOnlyChunkHash(e){return this.t.has(e)}async hasChunk(e){return await this.getChunk(e)!==void 0}async getChunk(e){let n=this.t.get(e);if(n!==void 0)return n;let o=this.n.get(e);return o===void 0&&(o=await(await this.y()).getChunk(e),o!==void 0&&this.n.put(o)),o}mustGetChunk(e){return an(this,e)}getHead(e){return Promise.resolve(this.u.get(e))}release(){this.#n||(this.#t(),this.#e?.then(e=>e.release()).catch(e=>{}),this.#n=!0)}get closed(){return this.#n}y(){return this.#e||(this.#e=this.f.read()),this.#e}},nr=class extends Jn{#e;#t;#n;i=new Map;r=new Map;s=new Map;#o=new Set;constructor(e,n,o,r,s,i,a,l,u){super(e,n,o,r,a,u),this.#e=s,this.#t=i,this.#n=l}createChunk=(e,n)=>{let o=on(e,n,this.#n);return this.#o.add(o.hash),o};putChunk(e,n){let{hash:o,meta:r}=e;if(this.assertValidHash(o),r.length>0)for(let s of r)this.assertValidHash(s);return this.#o.has(o)||this.isMemOnlyChunkHash(o)?this.r.set(o,e):this.s.set(o,{chunk:e,size:n??-1}),U}async setHead(e,n){await this.#r(e,n)}async removeHead(e){await this.#r(e,void 0)}async#r(e,n){let o=await this.getHead(e),r=this.i.get(e);r===void 0?this.i.set(e,{new:n,old:o}):r.new=n}isMemOnlyChunkHash(e){return this.r.has(e)||super.isMemOnlyChunkHash(e)}async getChunk(e){let n=this.r.get(e);if(n!==void 0)return n;let o=this.t.get(e);if(o!==void 0)return o;let r=this.s.get(e);if(r!==void 0)return r.chunk;let s=this.n.get(e);return s===void 0&&(s=await(await this.y()).getChunk(e),s!==void 0&&this.s.set(s.hash,{chunk:s,size:-1})),s}getHead(e){let n=this.i.get(e);return n?Promise.resolve(n.new):super.getHead(e)}async commit(){let e=new Set(St(this.r.keys(),this.s.keys())),n=await rn(this.i.values(),e,this);for(let[o,r]of n)if(this.isMemOnlyChunkHash(o)){if(r===0)this.#e.delete(o),this.t.delete(o),this.#t.delete(o);else{this.#e.set(o,r);let s=this.r.get(o);s&&(this.#t.set(o,s.meta),this.t.set(o,s))}n.delete(o)}this.n.updateForCommit(this.s,n);for(let[o,r]of this.i)r.new?this.u.set(o,r.new):this.u.delete(o);this.r.clear(),this.s.clear(),this.i.clear(),this.release()}getRefCount(e){return this.#e.get(e)}getRefs(e){let n=this.r.get(e);if(n)return n.meta;let o=this.t.get(e);if(o)return o.meta;let r=this.s.get(e);return r!==void 0?r.chunk.meta:this.#t.get(e)}areRefsCounted(e){return this.#t.has(e)}chunksPersisted(e){let n=[];for(let o of e){let r=this.t.get(o);r&&(this.t.delete(o),n.push(r))}this.n.persisted(n)}},or=class{#e;#t;#n;#o;#r=0;#s=!1;#a=[];cacheEntries=new Map;constructor(e,n,o,r){this.#e=e,this.#t=n,this.#n=o,this.#o=r}get(e){let n=this.cacheEntries.get(e);return n&&(this.cacheEntries.delete(e),this.cacheEntries.set(e,n)),n?.chunk}getWithoutUpdatingLRU(e){return this.cacheEntries.get(e)?.chunk}put(e){let{hash:n}=e,o=this.cacheEntries.get(n);if(o){this.cacheEntries.delete(n),this.cacheEntries.set(n,o);return}let r=this.#n.get(n);if(!(r===void 0||r<1)&&this.#c(e)){if(!this.#o.has(n)){for(let s of e.meta)this.#n.set(s,(this.#n.get(s)||0)+1);this.#o.set(n,e.meta)}this.#l()}}#l(){if(!this.#s)for(let e of this.cacheEntries.values()){if(this.#r<=this.#e)break;this.#h(e)}}#c(e,n){let o=n??this.#t(e);return o>this.#e?!1:(this.#r+=o,this.cacheEntries.set(e.hash,{chunk:e,size:o}),!0)}#h(e){let{hash:n}=e.chunk;this.#r-=e.size,this.cacheEntries.delete(n)}#u(e){this.#n.delete(e),this.#o.delete(e);let n=this.cacheEntries.get(e);n&&(this.#r-=n.size,this.cacheEntries.delete(e))}updateForCommit(e,n){for(let[o,r]of n)if(r===0)this.#s?(this.#n.set(o,0),this.#a.push(o)):this.#u(o);else{this.#n.set(o,r);let s=e.get(o);if(s){let{chunk:i,size:a}=s,l=this.cacheEntries.get(o);l?(this.cacheEntries.delete(o),this.cacheEntries.set(o,l)):(this.#c(i,a!==-1?a:void 0),this.#o.set(o,i.meta))}}this.#l()}persisted(e){for(let n of e)this.#c(n);this.#l()}async withSuspendedEvictsAndDeletes(e){this.#s=!0;try{return await e()}finally{this.#s=!1;for(let n of this.#a)this.#n.get(n)===0&&this.#u(n);this.#l()}}};function Ye(t){return t.indexName!==void 0}function Lt(t){return typeof t=="string"?[t]:t}function Ks(t){if(!t)return{};let e,n,o,r;return t.start&&({key:e,exclusive:n}=t.start,t.indexName?typeof e=="string"?r=e:(r=e[0],o=e[1]):o=e),{prefix:t.prefix,startSecondaryKey:r,startKey:o,startExclusive:n,limit:t.limit,indexName:t.indexName}}var jt=class extends Error{constructor(){super("Transaction is closed")}};function xe(t){if(t.closed)throw new jt}function rr(t){return t.closed?Promise.reject(new jt):void 0}var Xe=class{#e;#t;#n;#o;constructor(e,n,o,r){this.#e=e,this.#t=n,this.#n=o,this.#o=r}[Symbol.asyncIterator](){return this.values()}values(){return new zt(this.#r(e=>e[1]))}keys(){return new zt(this.#r(e=>e[0]))}entries(){return new zt(this.#r(e=>[e[0],e[1]]))}toArray(){return this.values().toArray()}#r(e){return Jl(e,this.#e,this.#t,this.#n,this.#o)}},zt=class{#e;constructor(e){this.#e=e}next(){return this.#e.next()}[Symbol.asyncIterator](){return this.#e[Symbol.asyncIterator]()}toArray(){return Hn(this.#e)}};async function*Jl(t,e,n,o,r){xe(o);let{limit:s=1/0}=n,{prefix:i=""}=n,a=n.start?.exclusive,l=Ye(n);for await(let u of e){let c=u[0];if(!(l?c[0]:c).startsWith(i))return;if(a){if(a=!0,l){if(Gl(c,n.start.key))continue}else if(Ul(c,n.start.key))continue}if(yield t(u),--s===0&&!l){r(c);return}}}function Gl(t,e){let[n,o]=Lt(e),[r,s]=Lt(t);return r!==n?!1:o===void 0?!0:s===o}function Ul(t,e){return t===e}function _l(t,e){if(Ye(t)){let[o,r]=Kl(t);return new Xe(e(t.indexName,o,r),t,{closed:!1},s=>{})}let n=sr(t);return new Xe(e(n),t,{closed:!1},o=>{})}function Kl(t){let{prefix:e,start:n}=t,o=[e??"",void 0];if(!n)return o;let r=Lt(n.key);return Pe(r[0],o[0])||r[0]===o[0]&&r[1]!==void 0?r:o}function Bs(t){let{prefix:e,start:n}=t,o="";if(e!==void 0&&(o=_o(e,void 0)),!n)return o;let{key:r}=n,[s,i]=Lt(r),a=_o(s,i);return Pe(a,o)?a:o}var Bl=0,Jt=class{clientID;dbtx;d;location;environment;constructor(e,n,o,r="openReadTransaction"){this.clientID=e,this.dbtx=n,this.d=o.withContext(r).withContext("txid",Bl++),this.environment="client",this.location="client"}get(e){return rr(this.dbtx)||this.dbtx.get(e)}async has(e){return xe(this.dbtx),this.dbtx.has(e)}async isEmpty(){return xe(this.dbtx),this.dbtx.isEmpty()}scan(e){return qs(e,this.dbtx,ql)}};function ql(t){}function qs(t,e,n){let o=Wl(e,t);return $l(o,t??{},e,n)}var Gn=class{#e=new Set;#t=[];#n;constructor(e){this.#n=e}get environment(){return this.#n.location}get location(){return this.#n.location}get clientID(){return this.#n.clientID}isEmpty(){return this.#t.push({options:{}}),this.#n.isEmpty()}get(e){return this.#e.add(e),this.#n.get(e)}has(e){return this.#e.add(e),this.#n.has(e)}scan(e){let n={options:Ks(e),inclusiveLimitKey:void 0};return this.#t.push(n),qs(e,this.#n.dbtx,o=>{n.inclusiveLimitKey=o})}get keys(){return this.#e}get scans(){return this.#t}},Ze=class extends Jt{reason;mutationID;constructor(e,n,o,r,s,i="openWriteTransaction"){super(e,r,s,i),this.mutationID=n,this.reason=o}put(e,n){return this.set(e,n)}async set(e,n){xe(this.dbtx),await this.dbtx.put(this.d,e,E(n))}del(e){return rr(this.dbtx)??this.dbtx.del(this.d,e)}};function Wl(t,e){return e&&Ye(e)?Yl(t,e):t.map.scan(sr(e))}function sr(t){if(!t)return"";let{prefix:e="",start:n}=t;return n&&Pe(n.key,e)?n.key:e}function $l(t,e,n,o){return new Xe(t,e,n,o)}async function*Yl(t,e){let n=t.getMapForIndex(e.indexName);for await(let o of n.scan(Bs(e)))yield[qe(o[0]),o[1]]}async function Ws(t,e,n,o,r,s,i){let a=t.meta,l=a.mutatorName;Be(a)&&y(a.clientID===s,"mutationClientID must match clientID of LocalMeta");let u=o[l];u||r.error?.(`Cannot rebase unknown mutator ${l}`);let c=u||(async()=>{}),d=a.mutatorArgsJSON,f=await(await O(n,e)).getNextMutationID(s,e);if(f!==a.mutationID)throw new Error(`Inconsistent mutation ID: original: ${a.mutationID}, next: ${f} - mutationClientID: ${s} mutatorName: ${l}`);i>=5&&Lo(a);let g=await Tn(n,l,d,t.chunk.hash,e,a.timestamp,s,i),m=new Ze(s,await g.getMutationID(),"rebase",g,r);return await c(m,d),g}async function Un(t,e,n,o,r,s,i){return(await Ws(t,e,n,o,r,s,i)).putCommit()}async function $s(t,e,n,o,r,s,i,a){return(await Ws(t,e,n,r,s,i,a)).commit(o)}function Ys(t,e){return H(t,async n=>{let o=await n.getHead(e);if(o===void 0)throw new Error(`No head found for ${e}`);return o})}function Xs(t){async function e(n,o){let[r,s]=await Xt(t.pushURL,t.auth,o,n);if(!r)return{httpRequestInfo:s};let i={httpRequestInfo:s},a;try{a=await r.json()}catch{return i}return(G(a)||K(a))&&(i.response=a),i}return Zs.add(e),e}var Zs=new WeakSet;function Qs(t){return Zs.has(t)}function _n(t){return t instanceof Error?t:new Error(String(t))}async function ir(t,e,n){for(let o of n)switch(o.op){case"put":{await e.put(t,o.key,E(o.value));break}case"del":await e.del(t,o.key);break;case"clear":await e.clear();break}}var Ee=class extends Error{name="PullError";causedBy;constructor(e){super("Failed to pull"),this.causedBy=e}};var Te="sync";var Zl=0,ei=1;function Ql(t){return t.pullVersion===ei}async function ti(t,e,n,o,r,s,i,a,l=!0){let[u,c]=await H(s,async m=>{let S=await m.getHead(N);if(!S)throw new Error("Internal no main head found");let D=await $(S,m),C=D.meta.cookieJSON;return[await D.getMutationID(e,m),C]}),d={profileID:t,clientID:e,cookie:c,lastMutationID:u,pullVersion:Zl,schemaVersion:n},{response:p,httpRequestInfo:f}=await ni(a,o,d,r);if(!p)return{httpRequestInfo:f,syncHead:T};if(!l||io(p))return{httpRequestInfo:f,pullResponse:p,syncHead:T};let g=await eu(a,s,c,p,e,i);if(g.type===2)throw new Error("Overlapping sync");return{httpRequestInfo:f,pullResponse:p,syncHead:g.type===0?g.syncHead:T}}async function Kn(t,e,n,o,r,s,i,a,l,u=!0){let c=await H(i,async m=>{let S=await m.getHead(N);if(!S)throw new Error("Internal no main head found");let I=(await $(S,m)).meta;return Pt(I),I.cookieJSON}),d={profileID:t,clientGroupID:n,cookie:c,pullVersion:ei,schemaVersion:o},{response:p,httpRequestInfo:f}=await ni(l,r,d,s);if(!p)return{httpRequestInfo:f,syncHead:T};if(!u||io(p))return{httpRequestInfo:f,pullResponse:p,syncHead:T};let g=await lr(l,i,c,p,e,a);return{httpRequestInfo:f,pullResponse:p,syncHead:g.type===0?g.syncHead:T}}async function ni(t,e,n,o){t.debug?.("Starting pull...");let r=Date.now();try{let s=await e(n,o);return t.debug?.(`...Pull ${s.response?"complete":"failed"} in `,Date.now()-r,"ms"),Ql(n)?jr(s):zr(s),s}catch(s){throw new Ee(_n(s))}}function eu(t,e,n,o,r,s){return he(e,async i=>{y(s<=4);let a=i,l=await a.getHead(N);if(l===void 0)throw new Error("Main head disappeared");let u=await $(l,a),[c,d]=vn(u,r);if(!W(n,d))return{type:2};if(o.lastMutationID<c)throw new Error(ar("lastMutationID",o.lastMutationID,c));let p=E(o.cookie??null);if(o.patch.length===0&&o.lastMutationID===c&&W(p,d))return{type:1};let f=await Nn(l,a),g;for(let D of f)if(await D.getMutationID(r,a)<=o.lastMutationID){g=D;break}if(!g)throw new Error("Internal invalid chain");let m=await Cs(u.chunk.hash,o.lastMutationID,p,i,An(g,i,s),r,s);await ir(t,m,o.patch);let S=new F(a,s,g.valueHash);for await(let D of m.map.diff(S))await En(t,m.indexes,D.key,()=>Promise.resolve(D.oldValue),D.newValue);return{type:0,syncHead:await m.commit(Te)}})}function ar(t,e,n){return`Received ${t} ${e} is < than last snapshot ${t} ${n}; ignoring client view`}function lr(t,e,n,o,r,s){return he(e,async i=>{let a=i,l=await a.getHead(N);if(l===void 0)throw new Error("Main head disappeared");let u=await $(l,a),c=u.meta;Pt(c);let d=c.cookieJSON;if(!W(n,d))return t.debug?.("handlePullResponse: cookie mismatch, pull response is not applicable"),{type:2};for(let[g,m]of Object.entries(o.lastMutationIDChanges)){let S=c.lastMutationIDs[g];if(S!==void 0&&m<S)throw new Error(ar(`${g} lastMutationID`,m,S))}let p=E(o.cookie);if(Ae(p,d)<0)throw new Error(ar("cookie",p,d));if(o.patch.length===0&&W(p,d)&&!tu(o.lastMutationIDChanges,c.lastMutationIDs))return{type:1};let f=await ws(u.chunk.hash,{...c.lastMutationIDs,...o.lastMutationIDChanges},p,i,r,s);return await ir(t,f,o.patch),{type:0,syncHead:await f.commit(Te)}})}function oi(t,e,n,o,r,s){return he(t,async i=>{let a=i,l=await a.getHead(Te);if(l===void 0)throw new Error("Missing sync head");if(l!==n)throw e.error?.("maybeEndPull, Wrong sync head. Expecting:",n,"got:",l),new Error("Wrong sync head");let u=await $(l,a),c=await a.getHead(N);if(c===void 0)throw new Error("Missing main head");let d=await $(c,a),{meta:p}=u,f=p.basisHash;if(u===null)throw new Error("Sync snapshot with no basis");if(f!==d.chunk.hash)throw new Error("Overlapping syncs");let g=await O(l,a),m=[],S=await kn(c,a);for(let C of S){let w=o;ve(C)&&(w=C.meta.clientID),await C.getMutationID(w,a)>await g.getMutationID(w,a)&&m.push(C)}m.reverse();let D=new He;if(m.length>0)return{syncHead:l,replayMutations:m,diffs:D};let I=await O(c,a);if(r.shouldComputeDiffs()){let C=new F(a,s,I.valueHash),w=new F(a,s,g.valueHash),P=await Ce(C,w);D.set("",P),await Ko(I,g,a,D,r,s)}if(await Promise.all([i.setHead(N,l),i.removeHead(Te)]),await i.commit(),e.debug){let[C,w]=vn(d,o),[P,x]=vn(u,o);e.debug("Successfully pulled new snapshot with lastMutationID:",P,"(prev:",C,"), cookie: ",x,"(prev:",w,"), sync head hash:",l,", main head hash:",c,", valueHash:",g.valueHash,"(prev:",d.valueHash)}return{syncHead:l,replayMutations:[],diffs:D}})}function tu(t,e){for(let[n,o]of Object.entries(t))if(o!==e[n])return!0;return!1}import*as Gt from"@badrap/valita";var ur=[],cr=h.unknown().chain(t=>{if(j)return Gt.ok(t);let e=Yt(t,ur)?Gt.ok(t):Gt.err({message:"Not a JSON value",path:ur.slice()});return ur.length=0,e});function ri(t){M(t),lt(t.httpRequestInfo),t.response!==void 0&&nu(t.response)}function nu(t){G(t)||Ar(t)}var Qe=class extends Error{name="PushError";causedBy;constructor(e){super("Failed to push"),this.causedBy=e}};var Bn=0,et=1,ou=Q({id:h.number(),name:h.string(),args:cr,timestamp:h.number()}),ru=Q({id:h.number(),name:h.string(),args:cr,timestamp:h.number(),clientID:Bo}),Fg=h.object({pushVersion:h.literal(0),schemaVersion:h.string(),profileID:h.string(),clientID:Bo,mutations:h.array(ou)}),Lg=h.object({pushVersion:h.literal(1),schemaVersion:h.string(),profileID:h.string(),clientGroupID:Ot,mutations:h.array(ru)});function su(t){return{id:t.mutationID,name:t.mutatorName,args:t.mutatorArgsJSON,timestamp:t.timestamp}}function iu(t){return{id:t.mutationID,name:t.mutatorName,args:t.mutatorArgsJSON,timestamp:t.timestamp,clientID:t.clientID}}async function Ut(t,e,n,o,r,s,i,a,l){let u=await H(e,async f=>{let g=await f.getHead(N);if(!g)throw new Error("Internal no main head");return kn(g,f)});if(u.length===0)return;u.reverse();let c;if(l===et){let f=[];for(let m of u)if(ve(m))f.push(iu(m.meta));else throw new Error("Internal non local pending commit");y(r),c={profileID:o,clientGroupID:r,mutations:f,pushVersion:et,schemaVersion:a}}else{y(l===Bn);let f=[];for(let g of u)if(To(g))f.push(su(g.meta));else throw new Error("Internal non local pending commit");c={profileID:o,clientID:s,mutations:f,pushVersion:Bn,schemaVersion:a}}n.debug?.("Starting push...");let d=Date.now(),p=await au(i,c,t);return n.debug?.("...Push complete in ",Date.now()-d,"ms"),p}async function au(t,e,n){try{let o=await t(e,n);return ri(o),o}catch(o){throw new Qe(_n(o))}}var ai=10*2**20,qn=class{#e=!1;#t;constructor(e){this.#t=e}async recoverMutations(e,n,o,r,s,i){let{lc:a,enableMutationRecovery:l,isPushDisabled:u,delegate:c}=this.#t;if(!l||this.#e||!c.online||c.closed||u())return!1;let d="Recovering mutations.";a.debug?.("Start:",d);try{this.#e=!0,await n,await li(r,this.#t,o,e);for(let p of Object.values(await s.getDatabases())){if(c.closed)return a.debug?.("Exiting early due to close:",d),!0;if(p.replicacheName===c.name&&p.name!==c.idbName)switch(p.replicacheFormatVersion){case 4:case 5:case 6:case 7:await uu(p,this.#t,void 0,i)}}}catch(p){_t(p,a,d,c)}finally{a.debug?.("End:",d),this.#e=!1}return!0}};function _t(t,e,n,o){o.closed?e.debug?.(`Mutation recovery error likely due to close during:
+var xr=Object.defineProperty;var Vi=Object.getOwnPropertyDescriptor;var Oi=Object.getOwnPropertyNames;var Ei=Object.prototype.hasOwnProperty;var Ti=(t,e)=>{for(var n in e)xr(t,n,{get:e[n],enumerable:!0})},wr=(t,e,n,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Oi(e))!Ei.call(t,r)&&r!==n&&xr(t,r,{get:()=>e[r],enumerable:!(o=Vi(e,r))||o.enumerable});return t},_=(t,e,n)=>(wr(t,e,"default"),n&&wr(n,e,"default"));var br="1.0",Qu=parseInt(br.split(".")[1],10);var Zn="/api/"+br,Qn="/api/:apiMajor.:apiMinor",Ai=Zn+"/customer",ec=Qn+"/customer",Rr=Zn+"/license/status",tc=Qn+"/license/status",kr=Zn+"/license/active",nc=Qn+"/license/active",st="/admin",oc=st+"/download",rc=st+"/license/:key",sc=st+"/licenses/active",ic=st+"/signups",ac=st+"/populate";function eo(t){no(t,"string")}function to(t){no(t,"boolean")}function no(t,e){typeof t!==e&&Pr(t,e)}function qt(t){t===null&&Pr(t,"object"),no(t,"object")}function Fi(t,e){let n="Invalid type: ";return t==null?n+=t:n+=`${typeof t} \`${t}\``,n+`, expected ${e}`}function Pr(t,e){throw new Error(Fi(t,e))}var mc=new URL("https://replicache-license.herokuapp.com/");async function oo(t,e,n,o,r){r=r.withContext("licenseActive");let s=new URL(kr,e),a=JSON.stringify({licenseKey:n,profileID:o});r.debug?.(`Sending ${s}`,a);let u=await(await t("post",s.toString(),a,{"Content-Type":"application/json",Accept:"application/json"})).text();r.debug?.(`Got ${s}`,u);let c=JSON.parse(u);Li(c)}async function ro(t,e,n,o){o=o.withContext("getLicenseStatus");let r=new URL(Rr,e),i=JSON.stringify({licenseKey:n});o.debug?.(`Sending ${r}`,i);let l=await(await t("post",r.toString(),i,{"Content-Type":"application/json",Accept:"application/json"})).text();o.debug?.(`Got ${r}`,l);let u=JSON.parse(l);return ji(u),u}function Li(t){qt(t)}function ji(t){qt(t),eo(t.status),to(t.disable),to(t.pleaseUpdate)}var it="This key only good for automated testing",zi=new URL("http://localhost:8080/"),Wt=new URL("https://replicache-license.herokuapp.com/"),Ji=new URL("https://replicache-license-staging.herokuapp.com/");import{consoleLogSink as nC}from"@rocicorp/logger";async function*Ui(t,e){for await(let n of t)e(n)&&(yield n)}function y(t,e="Assertion failed"){if(!t)throw new Error(e)}function k(t){$t(t,"string")}function A(t){$t(t,"number")}function Mr(t){$t(t,"boolean")}function $t(t,e){typeof t!==e&&re(t,e)}function M(t){t===null&&re(t,"object"),$t(t,"object")}function ue(t){Array.isArray(t)||re(t,"array")}function _i(t,e){let n="Invalid type: ";return t==null?n+=t:n+=`${typeof t} \`${t}\``,n+`, expected ${e}`}function re(t,e){throw new Error(_i(t,e))}function vr(t){if(t===null)throw new Error("Expected non-null value")}function at(t){if(t===void 0)throw new Error("Expected non undefined value")}function so(){throw new Error("Unreachable")}var j=process.env.NODE_ENV==="production";var Ki=Object.prototype.hasOwnProperty,X=Object.hasOwn||((t,e)=>Ki.call(t,e));function W(t,e){if(t===e)return!0;if(typeof t!=typeof e)return!1;switch(typeof t){case"boolean":case"number":case"string":return!1}if(t=t,Array.isArray(t)){if(!Array.isArray(e)||t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(!W(t[r],e[r]))return!1;return!0}if(t===null||e===null||Array.isArray(e))return!1;t=t,e=e;let n=0;for(let r in t)if(X(t,r)){if(!W(t[r],e[r]))return!1;n++}let o=0;for(let r in e)X(e,r)&&o++;return n===o}function te(t){if(!j){switch(typeof t){case"boolean":case"number":case"string":return;case"object":return t===null?void 0:Array.isArray(t)?Bi(t):Hr(t)}re(t,"JSON value")}}function Nr(t){M(t),Hr(t)}function Hr(t){for(let e in t)if(X(t,e)){let n=t[e];n!==void 0&&te(n)}}function Bi(t){for(let e of t)te(e)}function Yt(t,e){switch(typeof t){case"boolean":case"number":case"string":return!0;case"object":return t===null?!0:Array.isArray(t)?Wi(t,e):qi(t,e)}return!1}function qi(t,e){for(let n in t)if(X(t,n)){e.push(n);let o=t[n];if(o!==void 0&&!Yt(o,e))return!1;e.pop()}return!0}function Wi(t,e){for(let n=0;n<t.length;n++){if(e.push(n),!Yt(t[n],e))return!1;e.pop()}return!0}async function Xt(t,e,n,o){let r={headers:{"Content-type":"application/json",Authorization:e,"X-Replicache-RequestID":n},body:JSON.stringify(o),method:"POST"},s=new Request(t,r),i=await fetch(s),a=i.status;return a!==200?[void 0,{httpStatusCode:a,errorMessage:await i.text()}]:[i,{httpStatusCode:a,errorMessage:""}]}function Vr(t,e){return t===e?0:t<e?-1:1}function Ae(t,e){if(t===e)return 0;if(t===null)return-1;if(e===null)return 1;let n=Or(t),o=Or(e);return typeof n=="string"||typeof o=="string"?Vr(String(n),String(o)):n-o}function Or(t){return typeof t=="string"||typeof t=="number"?t:t.order}function Er(t){if(!(t===null||typeof t=="string"||typeof t=="number")&&(Nr(t),!(typeof t.order=="string"||typeof t.order=="number")))throw new Error("Invalid cookie")}function Tr(t,e){return typeof t=="object"&&t!==null&&t.error===e}function io(t){return typeof t.error=="string"}function G(t){return Tr(t,"ClientStateNotFound")}function K(t){if(!Tr(t,"VersionNotSupported"))return!1;let{versionType:e}=t;switch(e){case void 0:case"pull":case"push":case"schema":return!0}return!1}function Ar(t){y(K(t))}function lt(t){M(t),A(t.httpStatusCode),k(t.errorMessage)}function ao(t){ue(t);for(let e of t)$i(e)}function $i(t){switch(M(t),t.op){case"put":k(t.key),te(t.value);break;case"del":k(t.key);break;case"clear":break;default:throw new Error(`unknown patch op \`${t.op}\`, expected one of \`put\`, \`del\`, \`clear\``)}}function lo(t){async function e(n,o){let[r,s]=await Xt(t.pullURL,t.auth,o,n);return r?{response:await r.json(),httpRequestInfo:s}:{httpRequestInfo:s}}return Fr.add(e),e}var Fr=new WeakSet;function Lr(t){return Fr.has(t)}function Yi(t){if(M(t),G(t)||K(t))return;let e=t;e.cookie!==void 0&&te(e.cookie),A(e.lastMutationID),ao(e.patch)}function Xi(t){if(M(t),G(t)||K(t))return;let e=t;e.cookie!==void 0&&Er(e.cookie),Zi(e.lastMutationIDChanges),ao(e.patch)}function Zi(t){M(t);for(let[e,n]of Object.entries(t))k(e),A(n)}function jr(t){M(t),lt(t.httpRequestInfo),t.response!==void 0&&Xi(t.response)}function zr(t){M(t),lt(t.httpRequestInfo),t.response!==void 0&&Yi(t.response)}import{resolver as ta}from"@rocicorp/resolver";var Zt=new WeakSet;function E(t){return j||co(t,[]),t}function co(t,e){switch(typeof t){case"undefined":throw new TypeError("Unexpected value undefined");case"boolean":case"number":case"string":return;case"object":{if(t===null||Zt.has(t))return;Zt.add(t),e.includes(t)&&re(t,"Cyclic JSON object"),e.push(t),Object.freeze(t),Array.isArray(t)?Qi(t,e):ea(t,e),e.pop();return}default:re(t,"JSON value")}}function Qi(t,e){for(let n of t)co(n,e)}function ea(t,e){for(let n in t)if(X(t,n)){let o=t[n];o!==void 0&&co(o,e)}}function se(t){if(!j&&!uo(t,[]))throw new Error("Expected frozen object")}function uo(t,e){switch(typeof t){case"boolean":case"number":case"string":return!0;case"object":if(t===null||Zt.has(t))return!0;if(!Object.isFrozen(t))return!1;if(e.includes(t)&&re(t,"Cyclic JSON object"),e.push(t),Array.isArray(t)){for(let n of t)if(!uo(n,e))return e.pop(),!1}else for(let n in t)if(X(t,n)){let o=t[n];if(o!==void 0&&!uo(o,e))return e.pop(),!1}return Zt.add(t),e.pop(),!0;default:re(t,"JSON value")}}function Qt(t){if(t!==void 0)return E(t)}var Jr=Promise.resolve(!0),Gr=Promise.resolve(!1),hp=Promise.resolve(void 0),U=Promise.resolve();var be=Symbol(),Fe=class{o=new Map;#e;constructor(e){this.#e=e}has(e){switch(this.o.get(e)){case void 0:return this.#e.has(e);case be:return Gr;default:return Jr}}async get(e){let n=this.o.get(e);switch(n){case be:return;case void 0:{let o=await this.#e.get(e);return Qt(o)}default:return n}}put(e,n){return this.o.set(e,E(n)),U}del(e){return this.o.set(e,be),U}release(){this.#e.release()}get closed(){return this.#e.closed}};var na={durability:"relaxed"},tn="chunks",Se=class{#e;#t=!1;#n=!1;constructor(e){this.#e=sa(e)}read(){return this.#o(ra)}write(){return this.#o(oa)}async close(){this.#n||(await this.#e).close(),this.#t=!0}get closed(){return this.#t}async#o(e){let n=async r=>{let{promise:s,resolve:i,reject:a}=ta(),l=indexedDB.open(r);l.onupgradeneeded=()=>{let c=l.transaction;vr(c),c.abort(),this.#n=!0,a(new ut(`Replicache IndexedDB not found: ${r}`))},l.onsuccess=()=>i(l.result),l.onerror=()=>a(l.error);let u=await s;return u.onversionchange=()=>u.close(),u},o=await this.#e;try{return e(o)}catch(r){if(!this.#t&&r instanceof DOMException){if(r.name==="InvalidStateError"){this.#e=n(o.name);let s=await this.#e;return e(s)}else if(r.name==="NotFoundError")throw this.#n=!0,indexedDB.deleteDatabase(o.name),new ut(`Replicache IndexedDB ${o.name} missing object store. Deleting db.`)}throw r}}},en=class{#e;#t=!1;constructor(e){this.#e=e}has(e){return new Promise((n,o)=>{let r=ho(this.#e).count(e);r.onsuccess=()=>n(r.result>0),r.onerror=()=>o(r.error)})}get(e){return new Promise((n,o)=>{let r=ho(this.#e).get(e);r.onsuccess=()=>n(Qt(r.result)),r.onerror=()=>o(r.error)})}release(){this.#t=!0}get closed(){return this.#t}},po=class extends Fe{#e;#t=!1;constructor(e){super(new en(e)),this.#e=e}commit(){return this.o.size===0?U:new Promise((e,n)=>{let o=this.#e,r=ho(o);for(let[s,i]of this.o)i===be?r.delete(s):r.put(i,s);o.oncomplete=()=>e(),o.onerror=()=>n(o.error)})}release(){this.#t=!0}get closed(){return this.#t}};function oa(t){let e=t.transaction(tn,"readwrite",na);return new po(e)}function ra(t){let e=t.transaction(tn,"readonly");return new en(e)}function ho(t){return t.objectStore(tn)}function sa(t){return new Promise((e,n)=>{if(typeof indexedDB === "undefined")return setTimeout(() => {n(new Error("no indexedDB API"))}, 1000);let o=indexedDB.open(t);o.onupgradeneeded=()=>{o.result.createObjectStore(tn)},o.onsuccess=()=>{let r=o.result;r.onversionchange=()=>r.close(),e(r)},o.onerror=()=>n(o.error)})}var ut=class extends Error{name="IDBNotFoundError"};import{RWLock as ia}from"@rocicorp/lock";var Le=class{#e;#t;#n=!1;constructor(e,n){this.#e=e,this.#t=n}release(){this.#t(),this.#n=!0}get closed(){return this.#n}has(e){return Promise.resolve(this.#e.has(e))}get(e){return Promise.resolve(this.#e.get(e))}};var nn=class extends Fe{#e;constructor(e,n){super(new Le(e,n)),this.#e=e}commit(){return this.o.forEach((e,n)=>{e===be?this.#e.delete(n):this.#e.set(n,e)}),this.o.clear(),this.release(),U}};var Ur=new Map;var ct=class{#e;#t;#n=!1;constructor(e){let n=Ur.get(e),o,r;n?{lock:o,map:r}=n:(o=new ia,r=new Map,Ur.set(e,{lock:o,map:r})),this.#t=o,this.#e=r}async read(){let e=await this.#t.read();return new Le(this.#e,e)}async write(){let e=await this.#t.write();return new nn(this.#e,e)}close(){return this.#n=!0,U}get closed(){return this.#n}};function mo(t){return t[Symbol.asyncIterator]?.()||t[Symbol.iterator]()}async function*aa(t,e,n){let o=mo(t),r=mo(e),s=await o.next(),i=await r.next();for(;;){if(s.done){if(i.done)return;yield i.value,i=await r.next();continue}if(i.done){yield s.value,s=await o.next();continue}let a=n(s.value,i.value);a===0?(yield i.value,s=await o.next(),i=await r.next()):a<0?(yield s.value,s=await o.next()):(yield i.value,i=await r.next())}}import{LogContext as As}from"@rocicorp/logger";var Z=class extends Error{name="AbortError"};import{resolver as Gp}from"@rocicorp/resolver";var la=Promise.resolve(),_p=new Promise(()=>{});function ce(t,e){return t===0?la:new Promise((n,o)=>{let r=setTimeout(()=>{n()},t);e&&e.addEventListener("abort",()=>{clearTimeout(r),o(new Z("Aborted"))})})}function ie(t,e,n,o,r){ua(t,e,n,o,r)}async function ua(t,e,n,o,r){if(!r.aborted){for(o=o.withContext("bgIntervalProcess",t),o.debug?.("Starting");!r.aborted;){try{await ce(n(),r)}catch(s){if(!(s instanceof Z))throw s}if(!r.aborted){o.debug?.("Running");try{await e()}catch(s){r.aborted?o.debug?.("Error running most likely due to close.",s):o.error?.("Error running.",s)}}}o.debug?.("Stopping")}}var h={};Ti(h,{assert:()=>ne,is:()=>pa,parse:()=>_r,readonly:()=>da,readonlyArray:()=>pt,readonlyObject:()=>Q,readonlyRecord:()=>dt,test:()=>Do});_(h,$p);import*as je from"@badrap/valita";import*as $p from"@badrap/valita";function go(t){switch(typeof t){case"string":case"number":case"boolean":return JSON.stringify(t);case"undefined":return"undefined";case"bigint":return t.toString()+"n";default:return t===null?"null":Array.isArray(t)?"array":typeof t}}function fo(t,e){if(!e?.length)return go(t);let n=t;for(let o of e)n=n[o];return go(n)}function yo(t,e,n=o=>String(o)){if(e.length===1)return n(e[0]);let o=`${n(e[e.length-2])} ${t} ${n(e[e.length-1])}`;return e.length===2?o:`${e.slice(0,-2).map(n).join(", ")}, ${o}`}function ca(t,e){let n=t.issues[0],{path:o}=n,r=o?.length?` at ${o.join(".")}`:"";switch(n.code){case"invalid_type":return`Expected ${yo("or",n.expected)}${r}. Got ${fo(e,o)}`;case"missing_value":{let s=o&&o.length>1?` at ${o.slice(0,-1).join(".")}`:"";return n.path?.length?`Missing property ${n.path.at(-1)}${s}`:`TODO Unknown missing property${s}`}case"invalid_literal":return`Expected literal value ${yo("or",n.expected,go)}${r} Got ${fo(e,o)}`;case"invalid_length":return`Expected array with length ${n.minLength===n.maxLength?n.minLength:`between ${n.minLength} and ${n.maxLength}`}${r}. Got array with length ${e.length}`;case"unrecognized_keys":return n.keys.length===1?`Unexpected property ${n.keys[0]}${r}`:`Unexpected properties ${yo("and",n.keys)}${r}`;case"invalid_union":return`Invalid union value${r}`;case"custom_error":{let{error:s}=n;return`${s?typeof s=="string"?s:s.message??"unknown":"unknown"}${r}. Got ${fo(e,o)}`}}}function _r(t,e,n){let o=Do(t,e,n);if(!o.ok)throw new TypeError(o.error);return o.value}function pa(t,e,n){return Do(t,e,n).ok}function ne(t,e,n){_r(t,e,n)}function Do(t,e,n){let o=e.try(t,n?{mode:n}:void 0);return o.ok?o:{ok:!1,error:ca(o,t)}}function da(t){return t}function Q(t){return je.object(t)}function pt(t){return je.array(t)}function dt(t){return je.record(t)}var pe=typeof crypto<"u"&&typeof crypto.randomUUID<"u"?ma:ha;function ha(){return ya(Uint8Array.from({length:36},()=>Math.random()*256))}function ma(){return crypto.randomUUID()}var fa=[0,0,0,0,0,0,0,0,2,0,0,0,0,2,3,0,0,0,2,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0];function ya(t){return fa.map((e,n)=>{switch(e){case 0:return(t[n]&15).toString(16);case 1:return((t[n]&3)+8).toString(16);case 3:return"4";case 2:return"-"}}).join("")}var ga=/^[0-9a-v-]+$/;var Da="00000000-0000-4000-8000-000000000000",T=Da,z=Sa("",pe);function Sa(t,e){let n,o=0;return()=>{n||(n=Ia(t,e()));let r=String(o++);return Ca(n,r)}}function Ia(t,e){return t+e.replaceAll("-","").slice(t.length)}function Ca(t,e){return y(e.length<=12),t+e.padStart(12,"0")}function wa(t){return typeof t=="string"&&ga.test(t)}function B(t){ne(t,de)}var de=h.string().assert(wa,"Invalid hash");var ht=class{hash;data;meta;constructor(e,n,o){y(!o.includes(e),"Chunk cannot reference itself"),se(n),this.hash=e,this.data=n,this.meta=o}};function So(t){if(!Array.isArray(t))throw new Error("Meta must be an array");for(let e of t)k(e)}function on(t,e,n){let o=n();return new ht(o,t,e)}function Io(){throw new Error("unexpected call to compute chunk hash")}function rn(t,e,n){return new Co(t,e,n).compute()}var Co=class{#e;#t;#n;#o;#r;#s;#a;#l;constructor(e,n,o){let r=[],s=[];for(let i of e)i.old!==i.new&&(i.old&&s.push(i.old),i.new&&r.push(i.new));this.#e=r,this.#t=s,this.#n=n,this.#o=o,this.#s=new Map,this.#a=new Map,this.#l=o.areRefsCounted!==void 0,this.#r=this.#l?new Set:null}async compute(){for(let e of this.#e)await this.#c(e,1);if(await Promise.all(Array.from(this.#n.values(),e=>this.#u(e))),this.#l){y(this.#o.areRefsCounted),y(this.#r);let e;do{e=!1;for(let n of this.#n.values())if(!this.#o.areRefsCounted(n)&&!this.#r.has(n)&&this.#s.get(n)!==0){await this.#h(n,1),e=!0;break}}while(e)}for(let e of this.#t)await this.#c(e,-1);if(!j)for(let[e,n]of this.#s)y(n>=0,`ref count update must be non-negative. ${e}:${n}`);return this.#s}async#c(e,n){await this.#u(e),this.#S(e,n)&&await this.#h(e,n)}async#h(e,n){if(e===T)return;let o=await this.#o.getRefs(e);if(j||y(o||this.#l&&!this.#n.has(e),"refs must be defined"),o!==void 0){this.#r?.add(e);let r=o.map(s=>this.#c(s,n));await Promise.all(r)}}#u(e){let n=this.#a.get(e);return n===void 0&&(n=(async()=>{let o=await this.#o.getRefCount(e)||0;return this.#s.set(e,o),o})(),this.#a.set(e,n)),n}#S(e,n){let o=this.#s.get(e);return A(o),this.#s.set(e,o+n),o===0&&n===1||o===1&&n===-1}};function mt(t){return`c/${t}/d`}function ft(t){return`c/${t}/m`}function sn(t){return`c/${t}/r`}function wo(t){return`h/${t}`}var yt=class extends Error{name="ChunkNotFoundError";hash;constructor(e){super(`Chunk not found ${e}`),this.hash=e}};async function an(t,e){let n=await t.getChunk(e);if(n)return n;throw new yt(e)}async function ze(t,e){let n=await e.getHead(t);return y(n,`Missing head ${t}`),n}var Ie=class{#e;#t;#n;constructor(e,n,o){this.#e=e,this.#t=n,this.#n=o}async read(){return new ln(await this.#e.read(),this.#n)}async write(){return new xo(await this.#e.write(),this.#t,this.#n)}close(){return this.#e.close()}},ln=class{e;assertValidHash;constructor(e,n){this.e=e,this.assertValidHash=n}hasChunk(e){return this.e.has(mt(e))}async getChunk(e){let n=await this.e.get(mt(e));if(n===void 0)return;let o=await this.e.get(ft(e)),r;return o!==void 0?(So(o),r=o):r=[],new ht(e,n,r)}mustGetChunk(e){return an(this,e)}async getHead(e){let n=await this.e.get(wo(e));if(n!==void 0)return B(n),n}release(){this.e.release()}get closed(){return this.e.closed}},xo=class extends ln{#e;#t=new Set;#n=new Map;constructor(e,n,o){super(e,o),this.#e=n}createChunk=(e,n)=>on(e,n,this.#e);get kvWrite(){return this.e}async putChunk(e){let{hash:n,data:o,meta:r}=e;this.assertValidHash(n);let s=mt(n),i=this.e.put(s,o),a;if(r.length>0){for(let l of r)this.assertValidHash(l);a=this.e.put(ft(n),r)}this.#t.add(n),await i,await a}setHead(e,n){return this.#o(e,n)}removeHead(e){return this.#o(e,void 0)}async#o(e,n){let o=await this.getHead(e),r=wo(e),s;n===void 0?s=this.e.del(r):s=this.e.put(r,n);let i=this.#n.get(e);i===void 0?this.#n.set(e,{new:n,old:o}):i.new=n,await s}async commit(){let e=await rn(this.#n.values(),this.#t,this);await this.#r(e),await this.e.commit()}async getRefCount(e){let n=await this.e.get(sn(e));if(n!==void 0){if(A(n),n<0||n>65535||n!==(n|0))throw new Error(`Invalid ref count ${n}. We expect the value to be a Uint16`);return n}}async getRefs(e){let n=await this.e.get(ft(e));return n===void 0?[]:(So(n),n)}async#r(e){let n=[];for(let[o,r]of e)if(r===0)n.push(this.#s(o));else{let s=sn(o);n.push(this.e.put(s,r))}await Promise.all(n)}async#s(e){await Promise.all([this.e.del(mt(e)),this.e.del(ft(e)),this.e.del(sn(e))]),this.#t.delete(e)}release(){this.e.release()}};function bo(t){if(t!==(t|0)||t<4||t>7)throw new Error(`Unsupported format version: ${t}`);return t}var Ro=class{#e;#t;#n;constructor(e,n){this.#e=e,this.#t=n,this.#n=new Se(n)}read(){return this.#o(e=>e.read())}write(){return this.#o(e=>e.write())}async#o(e){try{return await e(this.#n)}catch(n){if(xa(n))return this.#n instanceof Se&&(this.#e.info?.("Switching to MemStore because of Firefox private browsing error"),this.#n=new ct(this.#t)),e(this.#n);throw n}}close(){return this.#n.close()}get closed(){return this.#n.closed}};function xa(t){return Kr()&&t instanceof DOMException&&t.name==="InvalidStateError"&&t.message==="A mutation operation was attempted on a database that did not allow mutations."}function Kr(){return navigator.userAgent.includes("Firefox")}function gt(t,e){return Kr()?new Ro(t,e):new Se(e)}function ko(t){return new Promise((e,n)=>{let o=indexedDB.deleteDatabase(t);o.onsuccess=()=>e(),o.onerror=()=>n(o.error)})}function H(t,e){return Po(t.read(),e)}function he(t,e){return Po(t.write(),e)}function v(t,e){return Po(t.write(),async n=>{let o=await e(n);return await n.commit(),o})}async function Po(t,e){let n=await t;try{return await e(n)}finally{n.release()}}var ba=Q({prefix:h.string().optional(),jsonPointer:h.string(),allowEmpty:h.boolean().optional()}),Br=dt(ba);function Ra(t,e){return t.jsonPointer===e.jsonPointer&&(t.allowEmpty??!1)===(e.allowEmpty??!1)&&(t.prefix??"")===(e.prefix??"")}function un(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(let[n,o]of Object.entries(t)){let r=e[n];if(!r||!Ra(o,r))return!1}return!0}var ka=Q({headHash:de,mutatorNames:pt(h.string()),indexes:Br,mutationIDs:dt(h.number()),lastServerAckdMutationIDs:h.record(h.number()),disabled:h.boolean()}),qr="client-groups";function Pa(t){ne(t,ka)}function Ma(t){M(t);let e=new Map;for(let[n,o]of Object.entries(t))o!==void 0&&(Pa(o),e.set(n,o));return e}function va(t,e){let n={};for(let[o,r]of t.entries())e.assertValidHash(r.headHash),n[o]={...r,mutatorNames:[...r.mutatorNames.values()]};return E(n)}async function Na(t,e){let n=await e.getChunk(t);return Ma(n?.data)}async function ee(t){let e=await t.getHead(qr);return e?Na(e,t):new Map}async function cn(t,e){let n=await ee(e);for(let[o,r]of t){let s=n.get(o);Wr(r,s)}return $r(t,e)}async function Dt(t,e,n){let o=await ee(n),r=o.get(t);Wr(e,r);let s=new Map(o);return s.set(t,e),$r(s,n)}function Wr(t,e){let n=new Set(t.mutatorNames);y(n.size===t.mutatorNames.length,"A client group's mutatorNames must be a set."),e!==void 0&&(y(un(e.indexes,t.indexes),"A client group's index definitions must never change."),y(Mo(n,e.mutatorNames),"A client group's mutatorNames must never change."))}async function $r(t,e){let n=va(t,e),o=Array.from(t.values(),s=>s.headHash),r=e.createChunk(n,o);return await e.putChunk(r),await e.setHead(qr,r.hash),t}function Mo(t,e){if(e.length!==t.size)return!1;for(let n of e)if(!t.has(n))return!1;return!0}async function Re(t,e){return(await ee(e)).get(t)}function pn(t){for(let[e,n]of Object.entries(t.mutationIDs)){let o=t.lastServerAckdMutationIDs[e];if(o===void 0&&n!==0||o<n)return!0}return!1}async function dn(t,e){let n=await Re(t,e);if(!n)return;let o={...n,disabled:!0};await Dt(t,o,e)}function ke(t,e){let n=t.length,o=e.length,r=Math.min(n,o);for(let s=0;s<r;){let i=t.codePointAt(s),a=e.codePointAt(s);if(i!==a){if(i<128&&a<128)return i-a;let l=Zr(i,Yr),u=Zr(a,Xr);return Ha(Yr,l,Xr,u)}s+=Va(i)}return n-o}function Ha(t,e,n,o){let r=Math.min(e,o);for(let s=0;s<r;s++){let i=t[s],a=n[s];if(i!==a)return i-a}return e-o}function Va(t){return t>65535?2:1}var Qr=()=>Array.from({length:4},()=>0),Yr=Qr(),Xr=Qr();function Zr(t,e){if(t<128)return e[0]=t,1;let n,o;if(t<=2047)n=1,o=192;else if(t<=65535)n=2,o=224;else if(t<=1114111)n=3,o=240;else throw new Error("Invalid code point");e[0]=(t>>6*n)+o;let r=1;for(;n>0;n--){let s=t>>6*(n-1);e[r++]=128|s&63}return r}function Pe(t,e){return ke(t,e)>0}function hn(t,e){return ke(t,e)<0}function mn(t,e){return ke(t,e)<=0}function fn(t,e){let n=0;for(;n<t;){let o=n+(t-n>>1),r=e(o);if(r===0)return o;r>0?n=o+1:t=o}return n}function*St(...t){for(let e of t)yield*e}var vo=0,No=1;function es(t,e,n){return E([t,n>=7?e:e.map(o=>o.slice(0,2))])}async function Ct(t,e,n,o){let r=await n.getNode(e);if(o!==n.rootHash)return Ct(t,n.rootHash,n,n.rootHash);if(Ge(r))return r;let{entries:s}=r,i=me(t,s);i===s.length&&i--;let a=s[i];return Ct(t,a[1],n,o)}function me(t,e){return fn(e.length,n=>ke(t,e[n][0]))}function wt(t,e,n){return t!==e.length&&e[t][0]===n}function Ho(t,e,n){if(j&&e>=7)return t;ue(t),se(t),y(t.length>=2);let[o,r]=t;A(o),ue(r);let s=o>0?k:te;if(e>=7){for(let a of r)Oa(a,s);return t}let i=r.map(a=>Ea(a,s,n));return[o,i]}function Oa(t,e){ue(t),y(t.length>=3),k(t[0]),e(t[1]),A(t[2])}function Ea(t,e,n){ue(t),y(t.length>=2),k(t[0]),e(t[1]);let o=n(t[0],t[1]);return[t[0],t[1],o]}var gn=class{entries;hash;isMutable;#e=-1;constructor(e,n,o){this.entries=e,this.hash=n,this.isMutable=o}maxKey(){return this.entries[this.entries.length-1][0]}getChildNodeSize(e){if(this.#e!==-1)return this.#e;let n=e.chunkHeaderSize;for(let o of this.entries)n+=o[2];return this.#e=n}c(e){this.#e=-1,e.updateNode(this)}};function Vo(t,e){return es(t.level,t.entries,e)}var Me=class extends gn{level=0;set(e,n,o,r){let s,i=me(e,this.entries);return wt(i,this.entries,e)?s=1:s=0,Promise.resolve(this.#e(r,i,s,[e,n,o]))}#e(e,n,o,...r){if(this.isMutable)return this.entries.splice(n,o,...r),this.c(e),this;let s=yn(this.entries,n,o,...r);return e.newDataNodeImpl(s)}del(e,n){let o=me(e,this.entries);return wt(o,this.entries,e)?Promise.resolve(this.#e(n,o,1)):Promise.resolve(this)}async*keys(e){for(let n of this.entries)yield n[0]}async*entriesIter(e){for(let n of this.entries)yield n}};function yn(t,e,n,...o){let r=t.slice(0,e);for(let s=0;s<o.length;s++)r.push(o[s]);for(let s=e+n;s<t.length;s++)r.push(t[s]);return r}var xt=class t extends gn{level;constructor(e,n,o,r){super(e,n,r),this.level=o}async set(e,n,o,r){let s=me(e,this.entries);s===this.entries.length&&s--;let i=this.entries[s][1],l=await(await r.getNode(i)).set(e,n,o,r),u=l.getChildNodeSize(r);if(u>r.maxSize||u<r.minSize)return this.#e(r,s,l);let c=It(l,r.getEntrySize);return this.#t(r,s,c)}async#e(e,n,o){let r=this.level-1,s=this.entries,i,a,l;if(n>0){let p=s[n-1][1],f=await e.getNode(p);i=St(f.entries,o.entries),a=n-1,l=2}else if(n<s.length-1){let p=s[n+1][1],f=await e.getNode(p);i=St(o.entries,f.entries),a=n,l=2}else i=o.entries,a=n,l=1;let u=Oo(i,p=>p[2],e.minSize-e.chunkHeaderSize,e.maxSize-e.chunkHeaderSize),c=[];for(let p of u){let f=e.newNodeImpl(p,r),g=It(f,e.getEntrySize);c.push(g)}if(this.isMutable)return this.entries.splice(a,l,...c),this.c(e),this;let d=yn(s,a,l,...c);return e.newInternalNodeImpl(d,this.level)}#t(e,n,o){if(this.isMutable)return this.entries.splice(n,1,o),this.c(e),this;let r=yn(this.entries,n,1,o);return e.newInternalNodeImpl(r,this.level)}async del(e,n){let o=me(e,this.entries);if(o===this.entries.length)return this;let r=this.entries[o][1],s=await n.getNode(r),i=s.hash,a=await s.del(e,n);if(a.hash===i)return this;if(a.entries.length===0){let l=yn(this.entries,o,1);return n.newInternalNodeImpl(l,this.level)}if(o===0&&this.entries.length===1)return a;if(a.getChildNodeSize(n)>n.minSize){let l=It(a,n.getEntrySize);return this.#t(n,o,l)}return this.#e(n,o,a)}async*keys(e){for(let n of this.entries)yield*(await e.getNode(n[1])).keys(e)}async*entriesIter(e){for(let n of this.entries)yield*(await e.getNode(n[1])).entriesIter(e)}getChildren(e,n,o){let r=[];for(let s=e;s<n&&s<this.entries.length;s++)r.push(o.getNode(this.entries[s][1]));return Promise.all(r)}async getCompositeChildren(e,n,o){let{level:r}=this;if(n===0)return new t([],z(),r-1,!0);let s=await this.getChildren(e,e+n,o);if(r>1){let a=[];for(let l of s)a.push(...l.entries);return new t(a,z(),r-1,!0)}y(r===1);let i=[];for(let a of s)i.push(...a.entries);return new Me(i,z(),!0)}};function Dn(t,e,n,o){return n===0?new Me(t,e,o):new xt(t,e,n,o)}function Ge(t){return t.level===0}function Oo(t,e,n,o){let r=[],s=[],i=0,a=[];for(let l of t){let u=e(l);u>=o?(a.length>0&&(r.push(a),s.push(i)),r.push([l]),s.push(u),i=0,a=[]):i+u>=n?(a.push(l),r.push(a),s.push(i+u),i=0,a=[]):(i+=u,a.push(l))}return i>0&&(s.length>0&&i+s[s.length-1]<=o?r[r.length-1].push(...a):r.push(a)),r}var Sn=es(0,[],7),ts=new Me([],T,!1);function It(t,e){let n=t.maxKey(),o=t.hash,r=e(n,o);return[n,o,r]}var ae=1,Ue=4,Ta=5,Aa=8;function fe(t){switch(typeof t){case"string":return ae+Ue+t.length;case"number":return Fa(t)?t<=-(2**30)||t>=2**30-1?ae+Ta:ae+Ue:ae+Aa;case"boolean":return ae;case"object":if(t===null)return ae;if(Array.isArray(t)){let e=2*ae+Ue;for(let n of t)e+=fe(n);return e}{let e=t,n=2*ae+Ue;for(let o in e)if(X(e,o)){let r=e[o];r!==void 0&&(n+=fe(o)+fe(r))}return n}}throw new Error(`Invalid value. type: ${typeof t}, value: ${t}`)}function Fa(t){return t===(t|0)}var La=2*ae+Ue+ae+Ue;function In(t,e){return La+fe(t)+fe(e)}var ns=-1,rs=0,bt=1,Rt=2,wn=3,Cn=0,os=1;function*ss(t,e){let n=0,o=0,r;function s(a,l){a[wn]===ns&&(a[wn]=l)}function i(){return[n,0,0,ns]}for(;n<t.length&&o<e.length;)t[n][Cn]===e[o][Cn]?(W(t[n][os],e[o][os])?r&&(s(r,0),yield r,r=void 0):(r||(r=i()),r[Rt]++,r[bt]++,s(r,o)),n++,o++):t[n][Cn]<e[o][Cn]?(r||(r=i()),r[bt]++,n++):(r||(r=i()),r[Rt]++,s(r,o),o++);o<e.length&&(r||(r=i()),r[Rt]+=e.length-o,s(r,o)),n<t.length&&(r||(r=i()),r[bt]+=t.length-n),r&&(s(r,0),yield r)}var ja=11,F=class{p=new Map;a;l;rootHash;getEntrySize;chunkHeaderSize;constructor(e,n,o=T,r=In,s=ja){this.a=e,this.l=n,this.rootHash=o,this.getEntrySize=r,this.chunkHeaderSize=s}async getNode(e){if(e===T)return ts;let n=this.p.get(e);if(n)return n;let o=await this.a.mustGetChunk(e),r=Ho(o.data,this.l,this.getEntrySize),s=Dn(r[No],e,r[vo],!1);return this.p.set(e,s),s}async get(e){let n=await Ct(e,this.rootHash,this,this.rootHash),o=me(e,n.entries);if(wt(o,n.entries,e))return n.entries[o][1]}async has(e){let n=await Ct(e,this.rootHash,this,this.rootHash),o=me(e,n.entries);return wt(o,n.entries,e)}async isEmpty(){let{rootHash:e}=this,n=await this.getNode(this.rootHash);return this.rootHash!==e?this.isEmpty():n.entries.length===0}scan(e){return Eo(this.rootHash,()=>this.rootHash,this.rootHash,e,async n=>{let o=await this.getNode(n);if(o)return[o.level,o.isMutable?o.entries.slice():o.entries];let r=await this.a.mustGetChunk(n);return Ho(r.data,this.l,this.getEntrySize)})}async*keys(){yield*(await this.getNode(this.rootHash)).keys(this)}async*entries(){yield*(await this.getNode(this.rootHash)).entriesIter(this)}[Symbol.asyncIterator](){return this.entries()}async*diff(e){let[n,o]=await Promise.all([this.getNode(this.rootHash),e.getNode(e.rootHash)]);yield*xn(o,n,e,this)}};async function*xn(t,e,n,o){if(t.level>e.level){let s=await t.getCompositeChildren(0,t.entries.length,n);yield*xn(s,e,n,o);return}if(e.level>t.level){let s=await e.getCompositeChildren(0,e.entries.length,o);yield*xn(t,s,n,o);return}if(Ge(t)&&Ge(e)){yield*za(t.entries,e.entries);return}let r=ss(t.entries,e.entries);for(let s of r){let[i,a]=await Promise.all([t.getCompositeChildren(s[rs],s[bt],n),e.getCompositeChildren(s[wn],s[Rt],o)]);yield*xn(i,a,n,o)}}function*za(t,e){let n=t.length,o=e.length,r=0,s=0;for(;r<n&&s<o;){let i=t[r][0],a=e[s][0];i===a?(W(t[r][1],e[s][1])||(yield{op:"change",key:i,oldValue:t[r][1],newValue:e[s][1]}),r++,s++):i<a?(yield{op:"del",key:i,oldValue:t[r][1]},r++):(yield{op:"add",key:a,newValue:e[s][1]},s++)}for(;r<n;r++)yield{op:"del",key:t[r][0],oldValue:t[r][1]};for(;s<o;s++)yield{op:"add",key:e[s][0],newValue:e[s][1]}}async function*Eo(t,e,n,o,r){if(n===T)return;let s=await r(n),i=s[No],a=0;if(o&&(a=me(o,i)),s[vo]>0)for(;a<i.length;a++)yield*Eo(t,e,i[a][1],o,r),o="";else for(;a<i.length;a++){let l=e();if(t!==l){yield*Eo(l,e,l,i[a][0],r);return}yield i[a]}}async function _e(t,e){let n=[],o=e==="add"?r=>({op:"add",key:r[0],newValue:r[1]}):r=>({op:"del",key:r[0],oldValue:r[1]});for await(let r of t.entries())n.push(o(r));return n}var N="main";function To(t){return Ka(t.meta)}function ve(t){return Be(t.meta)}function Ja(t){return ve(t)||To(t)}function Ga(t){return us(t.meta)}function Ua(t){return Wa(t.meta)}function Ao(t){return Ga(t)||Ua(t)}var bn=class{chunk;constructor(e){this.chunk=e}get meta(){return this.chunk.data.meta}get valueHash(){return this.chunk.data.valueHash}getMutationID(e,n){return Rn(e,n,this.meta)}async getNextMutationID(e,n){return await this.getMutationID(e,n)+1}get indexes(){return this.chunk.data.indexes}};async function Rn(t,e,n){switch(n.type){case 1:return n.lastMutationID;case 3:return n.lastMutationID;case 5:return n.lastMutationIDs[t]??0;case 2:return n.mutationID;case 4:{if(n.clientID===t)return n.mutationID;let{basisHash:o}=n,r=await O(o,e);return Rn(t,e,r.meta)}default:so()}}async function kn(t,e){return(await Nn(t,e)).filter(o=>Ja(o))}async function Pn(t,e){return(await Nn(t,e)).filter(o=>ve(o))}async function Mn(t,e,n){let o=[],r=new Map(Object.entries(e));for(;!Ao(t)&&r.size>0;){if(ve(t)){let{meta:i}=t,a=r.get(i.clientID);a!==void 0&&(i.mutationID<=a?r.delete(i.clientID):o.push(t))}let{basisHash:s}=t.meta;if(s===null)throw new Error(`Commit ${t.chunk.hash} has no basis`);t=await O(s,n)}return o}async function is(t,e){let n=await e.getHead(t);return y(n,`Missing head ${t}`),$(n,e)}async function Fo(t,e){return(await $(t,e)).chunk.hash}async function $(t,e){let n=await O(t,e);return Ne(n,e)}async function Ne(t,e){for(;!Ao(t);){let{meta:n}=t;if(Be(n))t=await O(n.baseSnapshotHash,e);else{let{basisHash:o}=n;if(o===null)throw new Error(`Commit ${t.chunk.hash} has no basis`);t=await O(o,e)}}return t}function vn(t,e){let n=t.meta;return us(n)?[n.lastMutationIDs[e]??0,n.cookieJSON]:[n.lastMutationID,n.cookieJSON]}function kt(t,e){return Ae(t.meta.cookieJSON,e.meta.cookieJSON)}async function Nn(t,e){let n=await O(t,e),o=[];for(;!Ao(n);){let{meta:r}=n,{basisHash:s}=r;if(s===null)throw new Error(`Commit ${n.chunk.hash} has no basis`);o.push(n),n=await O(s,e)}return o.push(n),o}async function O(t,e){let n=await e.mustGetChunk(t);return el(n)}async function Ke(t,e){let n=await ze(t,e);return O(n,e)}function _a(t){A(t.lastMutationID)}function as(t){if(A(t.mutationID),k(t.mutatorName),!t.mutatorName)throw new Error("Missing mutator name");te(t.mutatorArgsJSON),t.originalHash!==null&&B(t.originalHash),A(t.timestamp)}function Lo(t){k(t.clientID),as(t)}function Be(t){return t.type===4}function Ka(t){return t.type===2}function ls(t){t.basisHash!==null&&B(t.basisHash),te(t.cookieJSON)}function Ba(t){ls(t),A(t.lastMutationID)}function Pt(t){ls(t),qa(t.lastMutationIDs)}function qa(t){M(t);for(let e of Object.values(t))A(e)}function le(t){Pt(t.meta)}function us(t){return t.type===5}function Wa(t){return t.type===3}function $a(t){switch(M(t),se(t),t.basisHash!==null&&k(t.basisHash),A(t.type),t.type){case 1:_a(t);break;case 2:as(t);break;case 4:Lo(t);break;case 3:Ba(t);break;case 5:Pt(t);break;default:throw new Error(`Invalid enum value ${t.type}`)}}function cs(t,e){return t.jsonPointer===e.jsonPointer&&(t.allowEmpty??!1)===(e.allowEmpty??!1)&&t.keyPrefix===e.keyPrefix}function Ya(t){M(t),se(t),k(t.name),k(t.keyPrefix),k(t.jsonPointer),t.allowEmpty!==void 0&&Mr(t.allowEmpty)}function ps(t,e){return{name:t,keyPrefix:e.prefix??"",jsonPointer:e.jsonPointer,allowEmpty:e.allowEmpty??!1}}function Xa(t){M(t),se(t),Ya(t.definition),k(t.valueHash)}function Za(t){ue(t),se(t);for(let e of t)Xa(e)}function ds(t,e,n,o,r,s,i,a,l){return Mt(t,vt({type:2,basisHash:e,mutationID:n,mutatorName:o,mutatorArgsJSON:r,originalHash:s,timestamp:l},i,a))}function hs(t,e,n,o,r,s,i,a,l,u,c){return Mt(t,vt({type:4,basisHash:e,baseSnapshotHash:n,mutationID:o,mutatorName:r,mutatorArgsJSON:s,originalHash:i,timestamp:u,clientID:c},a,l))}function ms(t,e,n,o,r,s){return Mt(t,Qa(e,n,o,r,s))}function fs(t,e,n,o,r,s){return Mt(t,jo(e,n,o,r,s))}function Qa(t,e,n,o,r){return vt({type:3,basisHash:t,lastMutationID:e,cookieJSON:n},o,r)}function jo(t,e,n,o,r){return vt({type:5,basisHash:t,lastMutationIDs:e,cookieJSON:n},o,r)}function ys(t,e,n,o,r){return Mt(t,vt({type:1,basisHash:e,lastMutationID:n},o,r))}function el(t){return nl(t),new bn(t)}function Mt(t,e){return new bn(t(e,zo(e)))}function zo(t){let e=[t.valueHash],{meta:n}=t;switch(n.type){case 1:n.basisHash&&e.push(n.basisHash);break;case 2:case 4:n.basisHash&&e.push(n.basisHash);break;case 3:case 5:break;default:so()}for(let o of t.indexes)e.push(o.valueHash);return e}function vt(t,e,n){return E({meta:t,valueHash:e,indexes:n})}function tl(t){j||(M(t),se(t),$a(t.meta),k(t.valueHash),Za(t.indexes))}function nl(t){let{data:e}=t;tl(e);let n=new Set;for(let o of e.indexes){let{name:r}=o.definition;if(n.has(r))throw new Error(`Duplicate index ${r}`);n.add(r)}}async function Hn(t){let e=[];for await(let n of t)e.push(n);return e}function Ce(t,e){return Hn(e.diff(t))}import{Lock as ol}from"@rocicorp/lock";var we=class extends F{#e=new ol;#t=new Map;minSize;maxSize;constructor(e,n,o=T,r=8*1024,s=16*1024,i=In,a){super(e,n,o,i,a),this.minSize=r,this.maxSize=s}#n(e){y(e.isMutable),this.#t.set(e.hash,e),this.p.set(e.hash,e)}updateNode(e){y(e.isMutable),this.#t.delete(e.hash),e.hash=z(),this.#n(e)}newInternalNodeImpl(e,n){let o=new xt(e,z(),n,!0);return this.#n(o),o}newDataNodeImpl(e){let n=new Me(e,z(),!0);return this.#n(n),n}newNodeImpl(e,n){let o=Dn(e,z(),n,!0);return this.#n(o),o}put(e,n){return this.#e.withLock(async()=>{let o=await this.getNode(this.rootHash),r=this.getEntrySize(e,n),s=await o.set(e,n,r,this);if(s.getChildNodeSize(this)>this.maxSize){let i=this.chunkHeaderSize,a=Oo(s.entries,d=>d[2],this.minSize-i,this.maxSize-i),{level:l}=s,u=a.map(d=>{let p=this.newNodeImpl(d,l);return It(p,this.getEntrySize)}),c=this.newInternalNodeImpl(u,l+1);this.rootHash=c.hash;return}this.rootHash=s.hash})}del(e){return this.#e.withLock(async()=>{let o=await(await this.getNode(this.rootHash)).del(e,this),r=this.rootHash!==o.hash;return r&&(o.level>0&&o.entries.length===1?this.rootHash=o.entries[0][1]:this.rootHash=o.hash),r})}clear(){return this.#e.withLock(()=>{this.#t.clear(),this.rootHash=T})}flush(){return this.#e.withLock(async()=>{let e=this.a;if(this.rootHash===T){let r=e.createChunk(Sn,[]);return await e.putChunk(r),r.hash}let n=[],o=gs(this.rootHash,n,e.createChunk,this.#t,this.l);return await Promise.all(n.map(r=>e.putChunk(r))),this.#t.clear(),this.rootHash=o,o})}};function gs(t,e,n,o,r){let s=o.get(t);if(s===void 0)return t;if(Ge(s)){let u=n(Vo(s,r),[]);return e.push(u),u.hash}let i=[],{entries:a}=s;for(let u=0;u<a.length;u++){let c=a[u],d=c[1],p=gs(d,e,n,o,r);p!==d&&(a[u]=[c[0],p,c[2]]),i.push(p)}let l=n(Vo(s,r),i);return e.push(l),l.hash}function Jo(t){let e;return()=>(e===void 0&&(e=t()),e)}var Nt=class{meta;map;constructor(e,n){this.meta=e,this.map=n}},Vn=class extends Nt{flush(){return this.map.flush()}clear(){return this.map.clear()}};async function On(t,e,n,o,r,s,i){try{for(let a of rl(o,r,s,i))switch(n){case 0:await e.put(a,r);break;case 1:await e.del(a);break}}catch(a){t.info?.("Not indexing value",r,":",a)}}function rl(t,e,n,o){let r=sl(e,n);if(r===void 0){if(o)return[];throw new Error(`No value at path: ${n}`)}let s=Array.isArray(r)?r:[r],i=[];for(let a of s)if(typeof a=="string")i.push(Ds([a,t]));else throw new Error("Unsupported target type");return i}var Go="\0",Uo="\0";function Ds(t){let e=t[0],n=t[1];if(e.includes("\0"))throw new Error("Secondary key cannot contain null byte");return Go+e+Uo+n}function _o(t,e){let n=Ds([t,e||""]);return e===void 0?n.slice(0,n.length-1):n}function qe(t){if(t[0]!==Go)throw new Error("Invalid version");let e=Go.length,n=Uo.length,o=t.indexOf(Uo,e);if(o===-1)throw new Error("Invalid formatting");let r=t.slice(e,o),s=t.slice(o+n);return[r,s]}function sl(t,e){function n(s){if(!(s.startsWith("+")||s.startsWith("0")&&s.length!==1))return parseInt(s,10)}if(e==="")return t;if(!e.startsWith("/"))throw new Error(`Invalid JSON pointer: ${e}`);let o=e.split("/").slice(1).map(s=>s.replace(/~1/g,"/").replace(/~0/g,"~")),r=t;for(let s of o){let i;if(Array.isArray(r)){let a=n(s);if(a===void 0)return;i=r[a]}else{if(r===null)return;typeof r=="object"&&(r=r,i=r[s])}if(i===void 0)return;r=i}return r}var Ht=class{#e;map;indexes;constructor(e,n,o){this.#e=e,this.map=n,this.indexes=o}has(e){return this.map.has(e)}get(e){return this.map.get(e)}isEmpty(){return this.map.isEmpty()}getMapForIndex(e){let n=this.indexes.get(e);if(n===void 0)throw new Error(`Unknown index name: ${e}`);return n.map}get closed(){return this.#e.closed}close(){this.#e.release()}};function Ss(t,e){return il(N,t,e)}async function il(t,e,n){let o=await Ke(t,e);return al(o,e,n)}function al(t,e,n){let o=We(t,e,n),r=new F(e,n,t.valueHash);return new Ht(e,r,o)}function We(t,e,n){let o=new Map;for(let r of t.indexes)o.set(r.definition.name,new Nt(r,new F(e,n,r.valueHash)));return o}var He=class extends Map{set(e,n){return n.length===0?this:super.set(e,n)}};async function Is(t,e,n,o,r){let s=new He;if(!o.shouldComputeDiffs())return s;let i=new F(n,r,t.valueHash),a=new F(n,r,e.valueHash),l=await Ce(i,a);return s.set("",l),await Ko(t,e,n,s,o,r),s}async function Ko(t,e,n,o,r,s){let i=We(t,n,s),a=We(e,n,s);for(let[l,u]of i){if(!r.shouldComputeDiffsForIndex(l))continue;let c=a.get(l);if(c!==void 0){y(c!==u);let d=await Ce(u.map,c.map);a.delete(l),o.set(l,d)}else{let d=await _e(u.map,"del");o.set(l,d)}}for(let[l,u]of a){if(!r.shouldComputeDiffsForIndex(l))continue;let c=await _e(u.map,"add");o.set(l,c)}}var Vt=class extends Ht{#e;#t;#n;#o;#r;constructor(e,n,o,r,s,i,a){super(e,n,s),this.#e=e,this.#t=o,this.#n=r,this.#o=i,this.#r=a,o===void 0?y(r.basisHash===T):y(r.basisHash===o.chunk.hash)}async put(e,n,o){if(this.#n.type===1)throw new Error("Not allowed");let r=Jo(()=>this.map.get(n));await En(e,this.indexes,n,r,o),await this.map.put(n,o)}getMutationID(){return Rn(this.#o,this.#e,this.#n)}async del(e,n){if(this.#n.type===1)throw new Error("Not allowed");let o=Jo(()=>this.map.get(n));return o!==void 0&&await En(e,this.indexes,n,o,void 0),this.map.del(n)}async clear(){if(this.#n.type===1)throw new Error("Not allowed");await this.map.clear();let e=[];for(let n of this.indexes.values())e.push(n.clear());await Promise.all(e)}async putCommit(){let e=await this.map.flush(),n=[];for(let s of this.indexes.values()){let i=await s.flush(),a={definition:s.meta.definition,valueHash:i};n.push(a)}let o,r=this.#n;switch(r.type){case 2:{let{basisHash:s,mutationID:i,mutatorName:a,mutatorArgsJSON:l,originalHash:u,timestamp:c}=r;o=ds(this.#e.createChunk,s,i,a,l,u,e,n,c);break}case 4:{y(this.#r>=5);let{basisHash:s,mutationID:i,mutatorName:a,mutatorArgsJSON:l,originalHash:u,timestamp:c}=r;o=hs(this.#e.createChunk,s,await Fo(s,this.#e),i,a,l,u,e,n,c,this.#o);break}case 3:{y(this.#r<=4);let{basisHash:s,lastMutationID:i,cookieJSON:a}=r;o=ms(this.#e.createChunk,s,i,a,e,n);break}case 5:{y(this.#r>5);let{basisHash:s,lastMutationIDs:i,cookieJSON:a}=r;o=fs(this.#e.createChunk,s,i,a,e,n);break}case 1:{let{basisHash:s,lastMutationID:i}=r;if(this.#t!==void 0){if(await this.#t.getMutationID(this.#o,this.#e)!==i)throw new Error("Index change must not change mutationID");if(this.#t.valueHash!==e)throw new Error("Index change must not change valueHash")}o=ys(this.#e.createChunk,s,i,e,n);break}}return await this.#e.putChunk(o.chunk),o}async commit(e){let o=(await this.putCommit()).chunk.hash;return await this.#e.setHead(e,o),await this.#e.commit(),o}async commitWithDiffs(e,n){let o=this.putCommit(),r=await this.#s(n),s=(await o).chunk.hash;return await this.#e.setHead(e,s),await this.#e.commit(),[s,r]}async#s(e){let n=new He;if(!e.shouldComputeDiffs())return n;let o=[];if(this.#t){let s=new F(this.#e,this.#r,this.#t.valueHash);o=await Ce(s,this.map)}n.set("",o);let r;this.#t?r=We(this.#t,this.#e,this.#r):r=new Map;for(let[s,i]of this.indexes){if(!e.shouldComputeDiffsForIndex(s))continue;let a=r.get(s);y(i!==a);let l=await(a?Ce(a.map,i.map):_e(i.map,"add"));n.set(s,l)}for(let[s,i]of r)if(!this.indexes.has(s)&&e.shouldComputeDiffsForIndex(s)){let a=await _e(i.map,"del");n.set(s,a)}return n}close(){this.#e.release()}};async function Tn(t,e,n,o,r,s,i,a){let l=await O(t,r),u=new we(r,a,l.valueHash),c=await l.getNextMutationID(i,r),d=An(l,r,a);return new Vt(r,u,l,a>=5?{type:4,basisHash:t,baseSnapshotHash:await Fo(t,r),mutatorName:e,mutatorArgsJSON:n,mutationID:c,originalHash:o,timestamp:s,clientID:i}:{type:2,basisHash:t,mutatorName:e,mutatorArgsJSON:n,mutationID:c,originalHash:o,timestamp:s},d,i,a)}async function Cs(t,e,n,o,r,s,i){y(i<=4);let a=await O(t,o),l=new we(o,i,a.valueHash);return new Vt(o,l,a,{basisHash:t,type:3,lastMutationID:e,cookieJSON:n},r,s,i)}async function ws(t,e,n,o,r,s){let i=await O(t,o),a=new we(o,s,i.valueHash);return new Vt(o,a,i,{basisHash:t,type:5,lastMutationIDs:e,cookieJSON:n},An(i,o,s),r,s)}async function En(t,e,n,o,r){let s=[];for(let i of e.values()){let{keyPrefix:a}=i.meta.definition;if(!a||n.startsWith(a)){let l=await o();l!==void 0&&s.push(On(t,i.map,1,n,l,i.meta.definition.jsonPointer,i.meta.definition.allowEmpty??!1)),r!==void 0&&s.push(On(t,i.map,0,n,r,i.meta.definition.jsonPointer,i.meta.definition.allowEmpty??!1))}}await Promise.all(s)}function An(t,e,n){let o=new Map;for(let r of t.indexes)o.set(r.definition.name,new Vn(r,new we(e,n,r.valueHash)));return o}async function xs(t,e,n,o,r,s,i){let a=new we(e,i);for await(let l of n.scan(o)){let u=l[0];if(!u.startsWith(o))break;await On(t,a,0,u,l[1],r,s)}return a}var Ot=h.string(),Bo=h.string();var bs=Q({heartbeatTimestampMs:h.number(),headHash:de,mutationID:h.number(),lastServerAckdMutationID:h.number()}),ll=Q({heartbeatTimestampMs:h.number(),headHash:de,tempRefreshHash:de.nullable(),clientGroupID:Ot}),Rs=Q({heartbeatTimestampMs:h.number(),refreshHashes:pt(de),persistHash:de.nullable(),clientGroupID:Ot});function ks(t){return t.refreshHashes!==void 0}function qo(t){return t.clientGroupID!==void 0}var Ps="clients",ul=h.union(bs,ll,Rs);function cl(t){ne(t,ul)}function Wo(t){ne(t,bs)}function $e(t){ne(t,Rs)}function pl(t){M(t);let e=new Map;for(let n in t)if(X(t,n)){let o=t[n];o!==void 0&&(cl(o),e.set(n,o))}return e}function dl(t,e){for(let n of t.values())ks(n)?(n.refreshHashes.forEach(e.assertValidHash),n.persistHash&&e.assertValidHash(n.persistHash)):(e.assertValidHash(n.headHash),qo(n)&&n.tempRefreshHash&&e.assertValidHash(n.tempRefreshHash));return E(Object.fromEntries(t))}async function q(t){let e=await t.getHead(Ps);return hl(e,t)}async function hl(t,e){if(!t)return new Map;let n=await e.getChunk(t);return pl(n?.data)}var Y=class extends Error{name="ClientStateNotFoundError";id;constructor(e){super(`Client state not found, id: ${e}`),this.id=e}};async function Ms(t,e){if(!await $o(t,e))throw new Y(t)}async function $o(t,e){return!!await Yo(t,e)}async function Yo(t,e){return(await q(e)).get(t)}async function Et(t,e){let n=await Yo(t,e);if(!n)throw new Y(t);return n}function vs(t,e,n,o,r,s){return he(n,async i=>{async function a(m,S,D,I){let C=jo(m,{},S,D,I),w=i.createChunk(C,zo(C)),P=pe(),x={heartbeatTimestampMs:Date.now(),refreshHashes:[w.hash],persistHash:null,clientGroupID:P},V=new Map(l).set(t,x),R={headHash:w.hash,mutatorNames:o,indexes:r,mutationIDs:{},lastServerAckdMutationIDs:{},disabled:!1};return await Promise.all([i.putChunk(w),ye(V,i),Dt(P,R,i)]),await i.commit(),[x,w.hash,V,!0]}let l=await q(i),u=await fl(i,o,r);if(u.type===Vs){let{clientGroupID:m,headHash:S}=u,D={clientGroupID:m,refreshHashes:[S],heartbeatTimestampMs:Date.now(),persistHash:null},I=new Map(l).set(t,D);return await ye(I,i),await i.commit(),[D,S,I,!1]}if(u.type===Ns){let m=i.createChunk(Sn,[]);await i.putChunk(m);let S=[];for(let[D,I]of Object.entries(r)){let C=ps(D,I);S.push({definition:C,valueHash:m.hash})}return a(null,null,m.hash,S)}y(u.type===Hs);let{snapshot:c}=u,d=[],{valueHash:p,indexes:f}=c,g=new F(i,s,p);for(let[m,S]of Object.entries(r)){let{prefix:D="",jsonPointer:I,allowEmpty:C=!1}=S,w={name:m,keyPrefix:D,jsonPointer:I,allowEmpty:C},P=ml(f,w);if(P)d.push({definition:w,valueHash:P.valueHash});else{let x=await xs(e,i,g,D,I,C,s);d.push({definition:w,valueHash:await x.flush()})}}return a(c.meta.basisHash,c.meta.cookieJSON,c.valueHash,d)})}function ml(t,e){return t.find(n=>cs(n.definition,e))}var Ns=0,Hs=1,Vs=2;async function fl(t,e,n){let o,r,s=new Set(e),i=await ee(t);for(let[a,l]of i){if(!l.disabled&&Mo(s,l.mutatorNames)&&un(n,l.indexes))return{type:Vs,clientGroupID:a,headHash:l.headHash};let u=await $(l.headHash,t);le(u);let{cookieJSON:c}=u.meta;(o===void 0||Ae(c,o)>0)&&(o=c,r=u)}return r?{type:Hs,snapshot:r}:{type:Ns}}function yl(t){let e=[];for(let n of t.values())ks(n)?(e.push(...n.refreshHashes),n.persistHash&&e.push(n.persistHash)):(e.push(n.headHash),qo(n)&&n.tempRefreshHash&&e.push(n.tempRefreshHash));return e}async function Os(t,e){let n=await Xo(t,e);if(n)return Re(n,e)}async function Xo(t,e){let n=await Yo(t,e);if(!(!n||!qo(n)))return n.clientGroupID}async function Tt(t,e,n){let o=await q(n),r=new Map(o).set(t,e);return ye(r,n)}async function ye(t,e){let n=dl(t,e),o=e.createChunk(n,yl(t));return await e.putChunk(o),await e.setHead(Ps,o.hash),o.hash}var gl=0,Dl="replicache-dbs-v"+gl,Sl="";function Es(){return Sl+Dl}var Fn="dbs",Ts="profileId";function Il(t){M(t);for(let[e,n]of Object.entries(t))k(e),Cl(n),y(e===n.name)}function Cl(t){M(t),k(t.name),k(t.replicacheName),A(t.replicacheFormatVersion),k(t.schemaVersion),t.lastOpenedTimestampMS!==void 0&&A(t.lastOpenedTimestampMS)}var Ve=class{#e;constructor(e){this.#e=e(Es())}putDatabase(e){return this.#t({...e,lastOpenedTimestampMS:Date.now()})}putDatabaseForTesting(e){return this.#t(e)}#t(e){return v(this.#e,async n=>{let r={...await Zo(n),[e.name]:e};return await n.put(Fn,r),r})}clearDatabases(){return v(this.#e,e=>e.del(Fn))}deleteDatabases(e){return v(this.#e,async n=>{let r={...await Zo(n)};for(let s of e)delete r[s];await n.put(Fn,r)})}getDatabases(){return H(this.#e,Zo)}close(){return this.#e.close()}getProfileID(){return v(this.#e,async e=>{let n=await e.get(Ts);return n===void 0&&(n=`p${pe().replace(/-/g,"")}`,await e.put(Ts,n)),k(n),n})}};async function Zo(t){let e=await t.get(Fn);return e||(e=E({})),Il(e),e}var wl=12*60*60*1e3,xl=30*24*60*60*1e3,bl=14*24*60*60*1e3,Rl=5*60*1e3;function Fs(t,e,n){let o=!0;ie("CollectIDBDatabases",async()=>{await kl(t,Date.now(),xl,bl)},()=>o?(o=!1,Rl):wl,e,n)}async function kl(t,e,n,o,r=Pl){let s=await t.getDatabases(),i=Object.values(s),l=(await Promise.all(i.map(async c=>[c.name,await Ml(c,e,n,o,r)]))).filter(c=>c[1]).map(c=>c[0]),{errors:u}=await js(t,l);if(u.length)throw u[0]}async function Ls(t,e){await ko(t),await e.deleteDatabases([t])}async function js(t,e){let n=await Promise.allSettled(e.map(async s=>(await Ls(s,t),s))),o=[],r=[];for(let s of n)s.status==="fulfilled"?o.push(s.value):r.push(s.reason);return{dropped:o,errors:r}}function Pl(t){let e=new Se(t);return new Ie(e,z,B)}async function Ml(t,e,n,o,r){if(t.replicacheFormatVersion>7)return!1;if(t.lastOpenedTimestampMS!==void 0){let a=t.replicacheFormatVersion>=5;return e-t.lastOpenedTimestampMS<(a?o:n)?!1:a?(y(t.replicacheFormatVersion===5||t.replicacheFormatVersion===6||t.replicacheFormatVersion===7),!await Vl(r(t.name))):!0}let s=r(t.name),i=await H(s,q);return await s.close(),vl(i,e,n)}function vl(t,e,n){for(let o of t.values())if(e-o.heartbeatTimestampMs<n)return!1;return!0}async function Nl(t,e=n=>gt(new As,n)){await Ls(t,new Ve(e))}async function zs(t=e=>gt(new As,e)){let e=new Ve(t),n=await e.getDatabases(),o=Object.values(n).map(s=>s.name);return await js(e,o)}function Hl(t){return zs(t)}async function Vl(t){let e=await H(t,ee);for(let n of e.values())if(pn(n))return!0;return!1}import{consoleLogSink as Au,LogContext as Fu,TeeLogSink as Lu}from"@rocicorp/logger";import{resolver as nt}from"@rocicorp/resolver";import{resolver as Ol}from"@rocicorp/resolver";function Js(t,e,n){return t?new Qo(t,e,n):new er}var Qo=class{#e;#t;#n=0;visibilityState;#o=new Set;constructor(e,n,o){this.#e=e,this.#t=n,this.visibilityState=e.visibilityState,this.#e.addEventListener("visibilitychange",this.#r,{signal:o})}#r=()=>{this.#e.visibilityState==="visible"?(clearTimeout(this.#n),this.#s("visible")):this.#n=setTimeout(()=>{this.#s("hidden")},this.#t)};#s(e){if(e!==this.visibilityState){this.visibilityState=e;for(let n of this.#o){let{resolve:o,state:r}=n;r===e&&(o(),this.#o.delete(n))}}}waitForVisible(){return this.#a("visible")}waitForHidden(){return this.#a("hidden")}#a(e){if(this.visibilityState===e)return Promise.resolve();let{promise:n,resolve:o}=Ol();return this.#o.add({resolve:o,state:e}),n}},El=Promise.resolve(),Tl=new Promise(()=>{}),er=class{visibilityState="visible";waitForVisible(){return El}waitForHidden(){return Tl}};function At(){return typeof document<"u"?document:void 0}var Ln=class{rep;invokeSend;maxConnections=1;constructor(e,n){this.rep=e,this.invokeSend=n}get maxDelayMs(){return this.rep.requestOptions.maxDelayMs}get minDelayMs(){return this.rep.requestOptions.minDelayMs}},jn=class extends Ln{debounceDelay=0;get watchdogTimer(){return this.rep.pullInterval}},zn=class extends Ln{get debounceDelay(){return this.rep.pushDelay}watchdogTimer=null};import{resolver as ge}from"@rocicorp/resolver";var Us=30,_s=6e4,Ft=class{#e=ge();#t=ge();#n=ge();#o;#r=!1;#s=0;#a;#l;constructor(e,n,o){this.#a=e,this.#o=n,this.#l=o,this.run()}close(){this.#r=!0,this.#s>0&&this.#n.resolve({error:Gs()})}async send(e){if(this.#r)return{error:Gs()};this.#s++,this.#a.debug?.("send",e),e?this.#t.resolve():await this.#l?.waitForVisible(),this.#e.resolve();let n=await this.#n.promise;return this.#s--,n}async run(){let e=[],n=ge(),o,r=0,s=this.#o,{debug:i}=this.#a,a=0;i?.("Starting connection loop");let l=u=>Promise.race([this.#t.promise,ce(u)]);for(;!this.#r;){i?.(tr(e)?"Last request failed. Trying again":"Waiting for a send");let u=[this.#e.promise],c=s.watchdogTimer;if(c!==null&&u.push(ce(c)),await Promise.race(u),this.#r||(i?.("Waiting for debounce"),await l(s.debounceDelay),this.#r))break;if(i?.("debounced"),this.#e=ge(),r>=s.maxConnections){if(i?.("Too many request in flight. Waiting until one finishes..."),await this.#u(),this.#r)break;i?.("...finished")}r>0||tr(e)?(a=Fl(a,s,e),i?.(tr(e)?"Last connection errored. Sleeping for":"More than one outstanding connection ("+r+"). Sleeping for",a,"ms")):a=0;let d=Math.min(s.maxDelayMs,Math.max(s.minDelayMs,a));if(o!==void 0){let p=Date.now()-o;if(d>p&&(await Promise.race([l(d-p),n.promise]),this.#r))break}r++,(async()=>{let p=Date.now(),f,g;try{o=p,i?.("Sending request"),this.#t=ge(),f=await s.invokeSend(),i?.("Send returned",f)}catch(S){i?.("Send failed",S),g=S,f=!1}if(this.#r){i?.("Closed after invokeSend");return}i?.("Request done",{duration:Date.now()-p,ok:f}),e.push({duration:Date.now()-p,ok:f}),jl(e)&&(n.resolve(),n=ge()),r--,this.#h();let m=this.#n;this.#n=ge(),g?m.resolve({error:g}):m.resolve(void 0),f||this.#e.resolve()})()}}#c=void 0;#h(){if(this.#c){let e=this.#c;this.#c=void 0,e()}}#u(){let{promise:e,resolve:n}=ge();return this.#c=n,e}},Al=9;function Gs(){return new Error("Closed")}function Fl(t,e,n){let{length:o}=n;if(o===0)return t;let{ok:r}=n[n.length-1],{maxConnections:s,minDelayMs:i}=e;if(!r)return t===0?i:t*2;if(o>1){let l=n[n.length-2];for(;n.length>Al;)n.shift();if(r&&!l.ok)return i}return Ll(n.filter(({ok:l})=>l).map(({duration:l})=>l))/s|0}function Ll(t){t.sort();let{length:e}=t,n=e>>1;return e%2===1?t[n]:(t[n-1]+t[n])/2}function tr(t){return t.length>0&&!t[t.length-1].ok}function jl(t){return t.length>1&&!t[t.length-2].ok&&t[t.length-1].ok}import{RWLock as zl}from"@rocicorp/lock";var Oe=class{#e=new zl;#t=new Map;#n;#o;#r;t=new Map;n;h=new Map;m=new Map;constructor(e,n,o,r,s=fe){this.n=new or(n,s,this.h,this.m),this.#n=e,this.#o=o,this.#r=r}async read(){let e=await this.#e.read();return new Jn(this.#t,this.t,this.n,this.#n,e,this.#r)}async write(){let e=await this.#e.write();return new nr(this.#t,this.t,this.n,this.#n,this.h,this.m,e,this.#o,this.#r)}close(){return U}isCached(e){return this.n.getWithoutUpdatingLRU(e)!==void 0}withSuspendedSourceCacheEvictsAndDeletes(e){return this.n.withSuspendedEvictsAndDeletes(e)}},Jn=class{u;t;n;f;#e=void 0;#t;#n=!1;assertValidHash;constructor(e,n,o,r,s,i){this.u=e,this.t=n,this.n=o,this.f=r,this.#t=s,this.assertValidHash=i}isMemOnlyChunkHash(e){return this.t.has(e)}async hasChunk(e){return await this.getChunk(e)!==void 0}async getChunk(e){let n=this.t.get(e);if(n!==void 0)return n;let o=this.n.get(e);return o===void 0&&(o=await(await this.y()).getChunk(e),o!==void 0&&this.n.put(o)),o}mustGetChunk(e){return an(this,e)}getHead(e){return Promise.resolve(this.u.get(e))}release(){this.#n||(this.#t(),this.#e?.then(e=>e.release()).catch(e=>{}),this.#n=!0)}get closed(){return this.#n}y(){return this.#e||(this.#e=this.f.read()),this.#e}},nr=class extends Jn{#e;#t;#n;i=new Map;r=new Map;s=new Map;#o=new Set;constructor(e,n,o,r,s,i,a,l,u){super(e,n,o,r,a,u),this.#e=s,this.#t=i,this.#n=l}createChunk=(e,n)=>{let o=on(e,n,this.#n);return this.#o.add(o.hash),o};putChunk(e,n){let{hash:o,meta:r}=e;if(this.assertValidHash(o),r.length>0)for(let s of r)this.assertValidHash(s);return this.#o.has(o)||this.isMemOnlyChunkHash(o)?this.r.set(o,e):this.s.set(o,{chunk:e,size:n??-1}),U}async setHead(e,n){await this.#r(e,n)}async removeHead(e){await this.#r(e,void 0)}async#r(e,n){let o=await this.getHead(e),r=this.i.get(e);r===void 0?this.i.set(e,{new:n,old:o}):r.new=n}isMemOnlyChunkHash(e){return this.r.has(e)||super.isMemOnlyChunkHash(e)}async getChunk(e){let n=this.r.get(e);if(n!==void 0)return n;let o=this.t.get(e);if(o!==void 0)return o;let r=this.s.get(e);if(r!==void 0)return r.chunk;let s=this.n.get(e);return s===void 0&&(s=await(await this.y()).getChunk(e),s!==void 0&&this.s.set(s.hash,{chunk:s,size:-1})),s}getHead(e){let n=this.i.get(e);return n?Promise.resolve(n.new):super.getHead(e)}async commit(){let e=new Set(St(this.r.keys(),this.s.keys())),n=await rn(this.i.values(),e,this);for(let[o,r]of n)if(this.isMemOnlyChunkHash(o)){if(r===0)this.#e.delete(o),this.t.delete(o),this.#t.delete(o);else{this.#e.set(o,r);let s=this.r.get(o);s&&(this.#t.set(o,s.meta),this.t.set(o,s))}n.delete(o)}this.n.updateForCommit(this.s,n);for(let[o,r]of this.i)r.new?this.u.set(o,r.new):this.u.delete(o);this.r.clear(),this.s.clear(),this.i.clear(),this.release()}getRefCount(e){return this.#e.get(e)}getRefs(e){let n=this.r.get(e);if(n)return n.meta;let o=this.t.get(e);if(o)return o.meta;let r=this.s.get(e);return r!==void 0?r.chunk.meta:this.#t.get(e)}areRefsCounted(e){return this.#t.has(e)}chunksPersisted(e){let n=[];for(let o of e){let r=this.t.get(o);r&&(this.t.delete(o),n.push(r))}this.n.persisted(n)}},or=class{#e;#t;#n;#o;#r=0;#s=!1;#a=[];cacheEntries=new Map;constructor(e,n,o,r){this.#e=e,this.#t=n,this.#n=o,this.#o=r}get(e){let n=this.cacheEntries.get(e);return n&&(this.cacheEntries.delete(e),this.cacheEntries.set(e,n)),n?.chunk}getWithoutUpdatingLRU(e){return this.cacheEntries.get(e)?.chunk}put(e){let{hash:n}=e,o=this.cacheEntries.get(n);if(o){this.cacheEntries.delete(n),this.cacheEntries.set(n,o);return}let r=this.#n.get(n);if(!(r===void 0||r<1)&&this.#c(e)){if(!this.#o.has(n)){for(let s of e.meta)this.#n.set(s,(this.#n.get(s)||0)+1);this.#o.set(n,e.meta)}this.#l()}}#l(){if(!this.#s)for(let e of this.cacheEntries.values()){if(this.#r<=this.#e)break;this.#h(e)}}#c(e,n){let o=n??this.#t(e);return o>this.#e?!1:(this.#r+=o,this.cacheEntries.set(e.hash,{chunk:e,size:o}),!0)}#h(e){let{hash:n}=e.chunk;this.#r-=e.size,this.cacheEntries.delete(n)}#u(e){this.#n.delete(e),this.#o.delete(e);let n=this.cacheEntries.get(e);n&&(this.#r-=n.size,this.cacheEntries.delete(e))}updateForCommit(e,n){for(let[o,r]of n)if(r===0)this.#s?(this.#n.set(o,0),this.#a.push(o)):this.#u(o);else{this.#n.set(o,r);let s=e.get(o);if(s){let{chunk:i,size:a}=s,l=this.cacheEntries.get(o);l?(this.cacheEntries.delete(o),this.cacheEntries.set(o,l)):(this.#c(i,a!==-1?a:void 0),this.#o.set(o,i.meta))}}this.#l()}persisted(e){for(let n of e)this.#c(n);this.#l()}async withSuspendedEvictsAndDeletes(e){this.#s=!0;try{return await e()}finally{this.#s=!1;for(let n of this.#a)this.#n.get(n)===0&&this.#u(n);this.#l()}}};function Ye(t){return t.indexName!==void 0}function Lt(t){return typeof t=="string"?[t]:t}function Ks(t){if(!t)return{};let e,n,o,r;return t.start&&({key:e,exclusive:n}=t.start,t.indexName?typeof e=="string"?r=e:(r=e[0],o=e[1]):o=e),{prefix:t.prefix,startSecondaryKey:r,startKey:o,startExclusive:n,limit:t.limit,indexName:t.indexName}}var jt=class extends Error{constructor(){super("Transaction is closed")}};function xe(t){if(t.closed)throw new jt}function rr(t){return t.closed?Promise.reject(new jt):void 0}var Xe=class{#e;#t;#n;#o;constructor(e,n,o,r){this.#e=e,this.#t=n,this.#n=o,this.#o=r}[Symbol.asyncIterator](){return this.values()}values(){return new zt(this.#r(e=>e[1]))}keys(){return new zt(this.#r(e=>e[0]))}entries(){return new zt(this.#r(e=>[e[0],e[1]]))}toArray(){return this.values().toArray()}#r(e){return Jl(e,this.#e,this.#t,this.#n,this.#o)}},zt=class{#e;constructor(e){this.#e=e}next(){return this.#e.next()}[Symbol.asyncIterator](){return this.#e[Symbol.asyncIterator]()}toArray(){return Hn(this.#e)}};async function*Jl(t,e,n,o,r){xe(o);let{limit:s=1/0}=n,{prefix:i=""}=n,a=n.start?.exclusive,l=Ye(n);for await(let u of e){let c=u[0];if(!(l?c[0]:c).startsWith(i))return;if(a){if(a=!0,l){if(Gl(c,n.start.key))continue}else if(Ul(c,n.start.key))continue}if(yield t(u),--s===0&&!l){r(c);return}}}function Gl(t,e){let[n,o]=Lt(e),[r,s]=Lt(t);return r!==n?!1:o===void 0?!0:s===o}function Ul(t,e){return t===e}function _l(t,e){if(Ye(t)){let[o,r]=Kl(t);return new Xe(e(t.indexName,o,r),t,{closed:!1},s=>{})}let n=sr(t);return new Xe(e(n),t,{closed:!1},o=>{})}function Kl(t){let{prefix:e,start:n}=t,o=[e??"",void 0];if(!n)return o;let r=Lt(n.key);return Pe(r[0],o[0])||r[0]===o[0]&&r[1]!==void 0?r:o}function Bs(t){let{prefix:e,start:n}=t,o="";if(e!==void 0&&(o=_o(e,void 0)),!n)return o;let{key:r}=n,[s,i]=Lt(r),a=_o(s,i);return Pe(a,o)?a:o}var Bl=0,Jt=class{clientID;dbtx;d;location;environment;constructor(e,n,o,r="openReadTransaction"){this.clientID=e,this.dbtx=n,this.d=o.withContext(r).withContext("txid",Bl++),this.environment="client",this.location="client"}get(e){return rr(this.dbtx)||this.dbtx.get(e)}async has(e){return xe(this.dbtx),this.dbtx.has(e)}async isEmpty(){return xe(this.dbtx),this.dbtx.isEmpty()}scan(e){return qs(e,this.dbtx,ql)}};function ql(t){}function qs(t,e,n){let o=Wl(e,t);return $l(o,t??{},e,n)}var Gn=class{#e=new Set;#t=[];#n;constructor(e){this.#n=e}get environment(){return this.#n.location}get location(){return this.#n.location}get clientID(){return this.#n.clientID}isEmpty(){return this.#t.push({options:{}}),this.#n.isEmpty()}get(e){return this.#e.add(e),this.#n.get(e)}has(e){return this.#e.add(e),this.#n.has(e)}scan(e){let n={options:Ks(e),inclusiveLimitKey:void 0};return this.#t.push(n),qs(e,this.#n.dbtx,o=>{n.inclusiveLimitKey=o})}get keys(){return this.#e}get scans(){return this.#t}},Ze=class extends Jt{reason;mutationID;constructor(e,n,o,r,s,i="openWriteTransaction"){super(e,r,s,i),this.mutationID=n,this.reason=o}put(e,n){return this.set(e,n)}async set(e,n){xe(this.dbtx),await this.dbtx.put(this.d,e,E(n))}del(e){return rr(this.dbtx)??this.dbtx.del(this.d,e)}};function Wl(t,e){return e&&Ye(e)?Yl(t,e):t.map.scan(sr(e))}function sr(t){if(!t)return"";let{prefix:e="",start:n}=t;return n&&Pe(n.key,e)?n.key:e}function $l(t,e,n,o){return new Xe(t,e,n,o)}async function*Yl(t,e){let n=t.getMapForIndex(e.indexName);for await(let o of n.scan(Bs(e)))yield[qe(o[0]),o[1]]}async function Ws(t,e,n,o,r,s,i){let a=t.meta,l=a.mutatorName;Be(a)&&y(a.clientID===s,"mutationClientID must match clientID of LocalMeta");let u=o[l];u||r.error?.(`Cannot rebase unknown mutator ${l}`);let c=u||(async()=>{}),d=a.mutatorArgsJSON,f=await(await O(n,e)).getNextMutationID(s,e);if(f!==a.mutationID)throw new Error(`Inconsistent mutation ID: original: ${a.mutationID}, next: ${f} - mutationClientID: ${s} mutatorName: ${l}`);i>=5&&Lo(a);let g=await Tn(n,l,d,t.chunk.hash,e,a.timestamp,s,i),m=new Ze(s,await g.getMutationID(),"rebase",g,r);return await c(m,d),g}async function Un(t,e,n,o,r,s,i){return(await Ws(t,e,n,o,r,s,i)).putCommit()}async function $s(t,e,n,o,r,s,i,a){return(await Ws(t,e,n,r,s,i,a)).commit(o)}function Ys(t,e){return H(t,async n=>{let o=await n.getHead(e);if(o===void 0)throw new Error(`No head found for ${e}`);return o})}function Xs(t){async function e(n,o){let[r,s]=await Xt(t.pushURL,t.auth,o,n);if(!r)return{httpRequestInfo:s};let i={httpRequestInfo:s},a;try{a=await r.json()}catch{return i}return(G(a)||K(a))&&(i.response=a),i}return Zs.add(e),e}var Zs=new WeakSet;function Qs(t){return Zs.has(t)}function _n(t){return t instanceof Error?t:new Error(String(t))}async function ir(t,e,n){for(let o of n)switch(o.op){case"put":{await e.put(t,o.key,E(o.value));break}case"del":await e.del(t,o.key);break;case"clear":await e.clear();break}}var Ee=class extends Error{name="PullError";causedBy;constructor(e){super("Failed to pull"),this.causedBy=e}};var Te="sync";var Zl=0,ei=1;function Ql(t){return t.pullVersion===ei}async function ti(t,e,n,o,r,s,i,a,l=!0){let[u,c]=await H(s,async m=>{let S=await m.getHead(N);if(!S)throw new Error("Internal no main head found");let D=await $(S,m),C=D.meta.cookieJSON;return[await D.getMutationID(e,m),C]}),d={profileID:t,clientID:e,cookie:c,lastMutationID:u,pullVersion:Zl,schemaVersion:n},{response:p,httpRequestInfo:f}=await ni(a,o,d,r);if(!p)return{httpRequestInfo:f,syncHead:T};if(!l||io(p))return{httpRequestInfo:f,pullResponse:p,syncHead:T};let g=await eu(a,s,c,p,e,i);if(g.type===2)throw new Error("Overlapping sync");return{httpRequestInfo:f,pullResponse:p,syncHead:g.type===0?g.syncHead:T}}async function Kn(t,e,n,o,r,s,i,a,l,u=!0){let c=await H(i,async m=>{let S=await m.getHead(N);if(!S)throw new Error("Internal no main head found");let I=(await $(S,m)).meta;return Pt(I),I.cookieJSON}),d={profileID:t,clientGroupID:n,cookie:c,pullVersion:ei,schemaVersion:o},{response:p,httpRequestInfo:f}=await ni(l,r,d,s);if(!p)return{httpRequestInfo:f,syncHead:T};if(!u||io(p))return{httpRequestInfo:f,pullResponse:p,syncHead:T};let g=await lr(l,i,c,p,e,a);return{httpRequestInfo:f,pullResponse:p,syncHead:g.type===0?g.syncHead:T}}async function ni(t,e,n,o){t.debug?.("Starting pull...");let r=Date.now();try{let s=await e(n,o);return t.debug?.(`...Pull ${s.response?"complete":"failed"} in `,Date.now()-r,"ms"),Ql(n)?jr(s):zr(s),s}catch(s){throw new Ee(_n(s))}}function eu(t,e,n,o,r,s){return he(e,async i=>{y(s<=4);let a=i,l=await a.getHead(N);if(l===void 0)throw new Error("Main head disappeared");let u=await $(l,a),[c,d]=vn(u,r);if(!W(n,d))return{type:2};if(o.lastMutationID<c)throw new Error(ar("lastMutationID",o.lastMutationID,c));let p=E(o.cookie??null);if(o.patch.length===0&&o.lastMutationID===c&&W(p,d))return{type:1};let f=await Nn(l,a),g;for(let D of f)if(await D.getMutationID(r,a)<=o.lastMutationID){g=D;break}if(!g)throw new Error("Internal invalid chain");let m=await Cs(u.chunk.hash,o.lastMutationID,p,i,An(g,i,s),r,s);await ir(t,m,o.patch);let S=new F(a,s,g.valueHash);for await(let D of m.map.diff(S))await En(t,m.indexes,D.key,()=>Promise.resolve(D.oldValue),D.newValue);return{type:0,syncHead:await m.commit(Te)}})}function ar(t,e,n){return`Received ${t} ${e} is < than last snapshot ${t} ${n}; ignoring client view`}function lr(t,e,n,o,r,s){return he(e,async i=>{let a=i,l=await a.getHead(N);if(l===void 0)throw new Error("Main head disappeared");let u=await $(l,a),c=u.meta;Pt(c);let d=c.cookieJSON;if(!W(n,d))return t.debug?.("handlePullResponse: cookie mismatch, pull response is not applicable"),{type:2};for(let[g,m]of Object.entries(o.lastMutationIDChanges)){let S=c.lastMutationIDs[g];if(S!==void 0&&m<S)throw new Error(ar(`${g} lastMutationID`,m,S))}let p=E(o.cookie);if(Ae(p,d)<0)throw new Error(ar("cookie",p,d));if(o.patch.length===0&&W(p,d)&&!tu(o.lastMutationIDChanges,c.lastMutationIDs))return{type:1};let f=await ws(u.chunk.hash,{...c.lastMutationIDs,...o.lastMutationIDChanges},p,i,r,s);return await ir(t,f,o.patch),{type:0,syncHead:await f.commit(Te)}})}function oi(t,e,n,o,r,s){return he(t,async i=>{let a=i,l=await a.getHead(Te);if(l===void 0)throw new Error("Missing sync head");if(l!==n)throw e.error?.("maybeEndPull, Wrong sync head. Expecting:",n,"got:",l),new Error("Wrong sync head");let u=await $(l,a),c=await a.getHead(N);if(c===void 0)throw new Error("Missing main head");let d=await $(c,a),{meta:p}=u,f=p.basisHash;if(u===null)throw new Error("Sync snapshot with no basis");if(f!==d.chunk.hash)throw new Error("Overlapping syncs");let g=await O(l,a),m=[],S=await kn(c,a);for(let C of S){let w=o;ve(C)&&(w=C.meta.clientID),await C.getMutationID(w,a)>await g.getMutationID(w,a)&&m.push(C)}m.reverse();let D=new He;if(m.length>0)return{syncHead:l,replayMutations:m,diffs:D};let I=await O(c,a);if(r.shouldComputeDiffs()){let C=new F(a,s,I.valueHash),w=new F(a,s,g.valueHash),P=await Ce(C,w);D.set("",P),await Ko(I,g,a,D,r,s)}if(await Promise.all([i.setHead(N,l),i.removeHead(Te)]),await i.commit(),e.debug){let[C,w]=vn(d,o),[P,x]=vn(u,o);e.debug("Successfully pulled new snapshot with lastMutationID:",P,"(prev:",C,"), cookie: ",x,"(prev:",w,"), sync head hash:",l,", main head hash:",c,", valueHash:",g.valueHash,"(prev:",d.valueHash)}return{syncHead:l,replayMutations:[],diffs:D}})}function tu(t,e){for(let[n,o]of Object.entries(t))if(o!==e[n])return!0;return!1}import*as Gt from"@badrap/valita";var ur=[],cr=h.unknown().chain(t=>{if(j)return Gt.ok(t);let e=Yt(t,ur)?Gt.ok(t):Gt.err({message:"Not a JSON value",path:ur.slice()});return ur.length=0,e});function ri(t){M(t),lt(t.httpRequestInfo),t.response!==void 0&&nu(t.response)}function nu(t){G(t)||Ar(t)}var Qe=class extends Error{name="PushError";causedBy;constructor(e){super("Failed to push"),this.causedBy=e}};var Bn=0,et=1,ou=Q({id:h.number(),name:h.string(),args:cr,timestamp:h.number()}),ru=Q({id:h.number(),name:h.string(),args:cr,timestamp:h.number(),clientID:Bo}),Fg=h.object({pushVersion:h.literal(0),schemaVersion:h.string(),profileID:h.string(),clientID:Bo,mutations:h.array(ou)}),Lg=h.object({pushVersion:h.literal(1),schemaVersion:h.string(),profileID:h.string(),clientGroupID:Ot,mutations:h.array(ru)});function su(t){return{id:t.mutationID,name:t.mutatorName,args:t.mutatorArgsJSON,timestamp:t.timestamp}}function iu(t){return{id:t.mutationID,name:t.mutatorName,args:t.mutatorArgsJSON,timestamp:t.timestamp,clientID:t.clientID}}async function Ut(t,e,n,o,r,s,i,a,l){let u=await H(e,async f=>{let g=await f.getHead(N);if(!g)throw new Error("Internal no main head");return kn(g,f)});if(u.length===0)return;u.reverse();let c;if(l===et){let f=[];for(let m of u)if(ve(m))f.push(iu(m.meta));else throw new Error("Internal non local pending commit");y(r),c={profileID:o,clientGroupID:r,mutations:f,pushVersion:et,schemaVersion:a}}else{y(l===Bn);let f=[];for(let g of u)if(To(g))f.push(su(g.meta));else throw new Error("Internal non local pending commit");c={profileID:o,clientID:s,mutations:f,pushVersion:Bn,schemaVersion:a}}n.debug?.("Starting push...");let d=Date.now(),p=await au(i,c,t);return n.debug?.("...Push complete in ",Date.now()-d,"ms"),p}async function au(t,e,n){try{let o=await t(e,n);return ri(o),o}catch(o){throw new Qe(_n(o))}}var ai=10*2**20,qn=class{#e=!1;#t;constructor(e){this.#t=e}async recoverMutations(e,n,o,r,s,i){let{lc:a,enableMutationRecovery:l,isPushDisabled:u,delegate:c}=this.#t;if(!l||this.#e||!c.online||c.closed||u())return!1;let d="Recovering mutations.";a.debug?.("Start:",d);try{this.#e=!0,await n,await li(r,this.#t,o,e);for(let p of Object.values(await s.getDatabases())){if(c.closed)return a.debug?.("Exiting early due to close:",d),!0;if(p.replicacheName===c.name&&p.name!==c.idbName)switch(p.replicacheFormatVersion){case 4:case 5:case 6:case 7:await uu(p,this.#t,void 0,i)}}}catch(p){_t(p,a,d,c)}finally{a.debug?.("End:",d),this.#e=!1}return!0}};function _t(t,e,n,o){o.closed?e.debug?.(`Mutation recovery error likely due to close during:
 ${n}
 Error:
 `,t):e.error?.(`Mutation recovery error during:
